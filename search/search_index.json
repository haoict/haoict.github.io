{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"$ make do"},{"location":"#welcome-to-haoict-techblog","title":"Welcome to Haoict TechBlog","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"#hot-articles","title":"Hot articles:","text":"<ul> <li>How to compile the MS-DOS from Microsoft open source</li> <li>Make your own Linux Distro From scratch</li> <li>Create a Kubernetes cluster (mainline kubernetes)</li> <li>Create a Kubernetes cluster (k3s)</li> <li>GitOps Development</li> </ul>"},{"location":"faqs/","title":"Frequently Asked Questions","text":""},{"location":"devops/","title":"Devops","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"devops/cicd/argocd/","title":"Devops","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"devops/cicd/jenkins/","title":"Devops","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"devops/cicd/gitops-development/","title":"Git Ops Development","text":""},{"location":"devops/cicd/gitops-development/#introduction","title":"Introduction","text":"<p>GitOps is a modern approach to continuous delivery and operational management that uses Git as the single source of truth for declarative infrastructure and applications. It automates deployment processes, ensuring consistency, reliability, and transparency.</p> <p></p>"},{"location":"devops/cicd/gitops-development/#key-concepts-of-gitops","title":"Key Concepts of GitOps","text":"<ol> <li>Declarative Infrastructure: Define infrastructure and application states using configuration files.</li> <li>Version Control: Store and track configuration files in Git repositories.</li> <li>Automated Deployment: Use CI/CD pipelines to apply changes from Git to the environment.</li> <li>Observability and Monitoring: Monitor and ensure the deployed state matches the desired state.</li> </ol>"},{"location":"devops/cicd/gitops-development/#benefits-of-gitops","title":"Benefits of GitOps","text":"<ul> <li>Consistency and Reliability: By using Git as the single source of truth, GitOps ensures that the deployed state is consistent with the desired state, reducing configuration drift and human errors.</li> <li>Auditability and Compliance: All changes are tracked in Git, providing a clear audit trail and facilitating compliance with regulatory requirements.</li> <li>Faster Recovery: In case of failures, teams can quickly revert to a previous known good state by rolling back changes in the Git repository.</li> <li>Improved Collaboration: GitOps promotes collaboration among team members by leveraging familiar Git workflows and pull requests for code reviews and approvals.</li> </ul>"},{"location":"devops/cicd/gitops-development/#implementing-gitops","title":"Implementing GitOps","text":"<ol> <li>Set Up a Git Repository: Create a Git repository to store your declarative configuration files for infrastructure and applications.</li> <li>Define Desired State: Write configuration files that define the desired state of your infrastructure and applications using tools like Kubernetes manifests, Helm charts, or Terraform scripts.</li> <li>Configure CI/CD Pipelines: Set up CI/CD pipelines to automatically apply changes from the Git repository to the target environment. Tools like Argo CD, Flux, or Jenkins can be used for this purpose.</li> <li>Monitor and Alert: Implement monitoring and alerting mechanisms to ensure the deployed state matches the desired state. Tools like Prometheus, Grafana, and Alertmanager can be used for observability.</li> </ol>"},{"location":"devops/cicd/gitops-development/#my-simple-example","title":"My simple example","text":""},{"location":"devops/cicd/gitops-development/#setup-git-repository","title":"Setup Git repository","text":"<p>I have a very simple website, it helps sending ebooks to eReaders (Kobo/Kindle) from PC or phones.</p> <p>The website: https://send.nghiendoc.com</p> <p></p> <p>You can find the source code of this website at: https://github.com/haoict/send2ereader</p>"},{"location":"devops/cicd/gitops-development/#setup-ci","title":"Setup CI","text":"<p>First thing first, containerize your application, here's the Dockerfile https://github.com/haoict/send2ereader/blob/master/Dockerfile</p> <p>I use CircleCI to build docker image of the website whenever there's a push commit to the master branch. To setup CircleCI, there's a lot of tutorial on the internet. Here's my circleci's config: https://github.com/haoict/send2ereader/blob/master/.circleci/config.yml</p>"},{"location":"devops/cicd/gitops-development/#setup-cd","title":"Setup CD","text":"<p>To deploy the application, I use Helm and Kubernetes, sorry but the helm chart repository is not open source, but here's how it looks like: </p> <p>My K8s cluster, (kind of, LOLOLOLOL): </p> <p>I use ArgoCD - a Kubernetes-native continuous deployment (CD) tool. Unlike external CD tools that only enable push-based deployments, Argo CD can pull updated code from Git repositories and deploy it directly to Kubernetes resources.</p>"},{"location":"devops/cicd/gitops-development/#connecting-things-together","title":"Connecting things together","text":"<p>I want to add css to this website to make it look fancier. So I'm gonna make a new commit and push</p> <p>After pushed, CircleCI should build a new docker image when you push a new commit: </p> <p>Argo is the most important part of this GitOps development, after CircleCI finished building the app's docker image, I can get the image's tag and update it in the helm deployment.yaml</p> <p> </p> <p>After pushing the helm deployment.yaml update. Argo will automatically detect the change and deploy it</p> <p></p> <p>Now the website has a fresh look</p> <p></p>"},{"location":"devops/cicd/gitops-development/#conclusion","title":"Conclusion","text":"<p>GitOps is a powerful approach to managing infrastructure and application deployments, offering numerous benefits in terms of consistency, reliability, and collaboration. By leveraging Git as the single source of truth and automating deployment processes, teams can achieve greater efficiency and agility in their operations. Implementing GitOps requires careful planning and adherence to best practices, but the rewards are well worth the effort.</p> <p>Embrace GitOps to streamline your development and operational workflows, and take your DevOps practices to the next level.</p>"},{"location":"devops/docker/","title":"Devops","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"devops/kubernetes/","title":"Devops","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"devops/kubernetes/create-k0s-cluster/","title":"Install k0s cluster","text":"<p>K0s is a simple, standalone Kubernetes distribution focused on minimalism and flexibility. Provides essential Kubernetes components with a pluggable architecture. Suitable for development, testing, and production use cases.</p> <p>K0s is more general-purpose and flexible, while K3s is tailored for edge computing and IoT deployments. Your choice depends on your specific use case and resource requirements.</p> <pre><code>sudo su -\ncurl -sSLf https://get.k0s.sh | sudo sh\nsudo mkdir -p /etc/k0s\nsudo k0s config create | sudo tee /etc/k0s/k0s.yaml\nsudo nano /etc/k0s/k0s.yaml\n--&gt; Add externalAddress: https://docs.k0sproject.io/head/configuration/ (normally it should be the same with server's public IP)\nsudo k0s install controller -c /etc/k0s/k0s.yaml --enable-worker\nsudo k0s start\nsudo k0s status\n</code></pre>"},{"location":"devops/kubernetes/create-k0s-cluster/#troubleshooting-if-errors","title":"Troubleshooting if errors","text":"<pre><code>sudo nano /etc/systemd/system/k0scontroller.service\nsudo systemctl daemon-reload\nsudo systemctl status k0scontroller.service\nsudo journalctl th\u00f4-u k0scontroller --follow\n</code></pre>"},{"location":"devops/kubernetes/create-k0s-cluster/#access-cluster","title":"Access cluster","text":""},{"location":"devops/kubernetes/create-k0s-cluster/#from-k0s-server","title":"from k0s server","text":"<pre><code>sudo k0s kubectl get nodes\n</code></pre>"},{"location":"devops/kubernetes/create-k0s-cluster/#from-local-pc","title":"from local pc","text":"<pre><code># Get admin.conf from k0s server first\nmkdir -p ${HOME}/.k0s\nsudo cat /var/lib/k0s/pki/admin.conf\n\n\n# From your local PC\nnano ~/.k0s/kubeconfig\n--&gt; Paste the content of admin.conf\n\nexport KUBECONFIG=\"${HOME}/.k0s/kubeconfig\"\nkubectl get pods --all-namespaces\n</code></pre>"},{"location":"devops/kubernetes/create-k0s-cluster/#uninstall","title":"Uninstall","text":"<pre><code>sudo k0s stop\nsudo k0s reset\n## Clean up\nsudo systemctl disable k0scontroller.service\nsudo rm /etc/systemd/system/k0scontroller.service\nsudo systemctl daemon-reload\n</code></pre>"},{"location":"devops/kubernetes/create-k3s-cluster/","title":"Install k3s cluster","text":"<p>K3s is a ightweight Kubernetes distribution optimized for edge computing, IoT, and resource-constrained environments. Includes additional features like lightweight container runtime, built-in load balancer, and integrated storage solutions. Designed for devices with limited memory and CPU resources.</p> <p>K0s is more general-purpose and flexible, while K3s is tailored for edge computing and IoT deployments. Your choice depends on your specific use case and resource requirements.</p> <p>Docs:</p> <ul> <li>https://docs.k3s.io/quick-start</li> <li>https://0to1.nl/post/k3s-kubectl-permission/</li> </ul> <p>Quick way: <pre><code># install control-plane node (with disable traefik and custom token)\ncurl -sfL https://get.k3s.io | sh -s - --disable=traefik --kube-apiserver-arg service-node-port-range=30000-39999 --token 12345\n\n# install worker nodes (optional)\ncurl -sfL https://get.k3s.io | K3S_URL=https://192.168.195.151:6443 K3S_TOKEN=12345 sh -s -\n\n# optional: copy kubeconfig to user .kube\nsudo cp /etc/rancher/k3s/k3s.yaml ~/.kube/config &amp;&amp; chown $USER ~/.kube/config &amp;&amp; chmod 600 ~/.kube/config &amp;&amp; export KUBECONFIG=~/.kube/config\n## You probably want to store that export to your bashrc or bash_profile. After you changed this you can use kubectl in a new terminal.\n\n# optional: taint control-plane node\nkubectl taint node k3s-01 node-role.kubernetes.io/control-plane:NoSchedule\n</code></pre></p>"},{"location":"devops/kubernetes/create-k3s-cluster/#delete-cluster","title":"Delete cluster","text":"<pre><code># Uninstalling Servers\n/usr/local/bin/k3s-uninstall.sh\n\n# Uninstalling Agents\n/usr/local/bin/k3s-agent-uninstall.sh\n</code></pre>"},{"location":"devops/kubernetes/create-k8s-cluster/","title":"Install kubernetes official way","text":"<p>Docs:</p> <ul> <li>https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/</li> <li>https://www.webhi.com/how-to/setup-configure-kubernetes-on-ubuntu-debian-and-centos-rhel/</li> <li>https://serverfault.com/a/1118760</li> </ul>"},{"location":"devops/kubernetes/create-k8s-cluster/#disable-swap","title":"Disable swap","text":"<p>Kubernetes performs best when swap is disabled. Disable it with the following commands:</p> <pre><code>sudo swapoff -a\nsudo sed -i '/ swap / s/^/#/' /etc/fstab\n</code></pre> <p>the swap patition will be unused, you may want to reclaim it and merge it to the root patition <pre><code># extend disk\nsudo cfdisk /dev/sda\n\n# check\nlsblk\nlsblk --fs\ndf -h\n\n# resize fs\nresize2fs /dev/sda1\n\n# check again\n</code></pre></p>"},{"location":"devops/kubernetes/create-k8s-cluster/#install-containerd-by-docker-engine","title":"Install containerd (by docker engine)","text":"<pre><code># Set up Docker's apt repository. (https://docs.docker.com/engine/install/debian/)\n# Add Docker's official GPG key:\nsudo apt-get update\nsudo apt-get install ca-certificates curl\nsudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n\n# Add the repository to Apt sources:\necho \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian $(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\") stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\n\n# install containerd.io \nsudo apt-get install containerd.io\n\n# Create containerd configuration\nsudo mkdir -p /etc/containerd\nsudo containerd config default | sudo tee /etc/containerd/config.toml\nsudo nano /etc/containerd/config.toml # set SystemdCgroup = true\nsudo systemctl restart containerd\n</code></pre>"},{"location":"devops/kubernetes/create-k8s-cluster/#install-kubernetes-components","title":"Install Kubernetes Components","text":"<pre><code>sudo apt-get update\nsudo apt-get install -y apt-transport-https ca-certificates curl gpg\ncurl -fsSL https://pkgs.k8s.io/core:/stable:/v1.29/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg\necho 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.29/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list # for other Kubernetes minor versions, you need to change the Kubernetes minor version in the URL to match your desired minor version\nsudo apt-get update\nsudo apt-get install -y kubelet kubeadm kubectl\nsudo apt-mark hold kubelet kubeadm kubectl\n\n# fix kubeadm init preflight issues\nsudo modprobe br_netfilter\ncat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-iptables  = 1\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.ipv4.ip_forward                 = 1\nEOF\nsudo sysctl --system\n\n# init cluster\nsudo kubeadm init --pod-network-cidr=10.244.0.0/16\n\n# post initialization\nmkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\n</code></pre>"},{"location":"devops/kubernetes/create-k8s-cluster/#configure-pod-network","title":"Configure Pod Network","text":"<p>Select a Pod network add-on and install it. For instance, you can choose to install Calico: <pre><code>kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml\n</code></pre> or Flannel <pre><code>kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/v0.20.2/Documentation/kube-flannel.yml\n</code></pre></p>"},{"location":"devops/kubernetes/create-k8s-cluster/#verify","title":"Verify","text":"<p>All should be running now: <pre><code>kubectl get pods --all-namespaces\n</code></pre></p>"},{"location":"devops/kubernetes/create-k8s-cluster/#join-worker-nodes-if-there-are","title":"Join worker nodes (if there are)","text":"<p>After step \"fix kubeadm init preflight issues\", instead of running \"kubeadm init\", we run: (this command should be printed out after master node kubeadm init) <pre><code>kubeadm join 192.168.195.130:6443 --token $TOKEN --discovery-token-ca-cert-hash $HASH\n</code></pre></p>"},{"location":"devops/kubernetes/create-k8s-cluster/#delete-cluster","title":"Delete cluster","text":"<pre><code>kubeadm reset\nsudo iptables -F &amp;&amp; sudo iptables -t nat -F &amp;&amp; sudo iptables -t mangle -F &amp;&amp; sudo iptables -X\n</code></pre>"},{"location":"devops/kubernetes/create-kind-cluster/","title":"Install Kind","text":"<p>This page is a WIP, check back later for more contents</p> <p>There are quite a few ways to get Kubernetes up and running on your machine. On Rancher Desktop, you simply click a Kubernetes checkbox in the settings. With a WSL2 backend this is pretty good, except you need a special distro running just for Kubernetes. It's also not compatible with ARM. Without using Rancher Desktop, we'll be looking for a Linux solution, some come to mind, including:</p> <ul> <li>minikube</li> <li>microk8s (requires snap, which is a bit of a pain on WSL2)</li> <li>k3s (does some things on the OS level which are not ideal)</li> <li>k3d</li> <li>kind</li> </ul> <p>kind is my favourite because of how isolated it is inside docker, which makes it very easy to get going, and just as easy to remove. k3d is very similar, but not a certified distribution, so you'll probably have higher chance of success with kind.</p> <p>https://www.guide2wsl.com/kubernetes/ https://kind.sigs.k8s.io/docs/user/quick-start/</p> <pre><code>kind create cluster --config cluster.yaml\nkind delete cluster\n</code></pre> <pre><code>kind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nnodes:\n- role: control-plane\n  extraPortMappings:\n  - containerPort: 80\n    hostPort: 8080\n  - containerPort: 443\n    hostPort: 8443\n# - role: worker\n</code></pre>"},{"location":"devops/terraform/","title":"Install Terraform","text":"<p>Docs:</p> <p>https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli</p>"},{"location":"devops/terraform/#destroy-terraform","title":"Destroy Terraform","text":"<pre><code>terraform destroy\n\n# remove stuck resources\nNS=`kubectl get ns |grep Terminating | awk 'NR==1 {print $1}'` &amp;&amp; kubectl get namespace \"$NS\" -o json   | tr -d \"\\n\" | sed \"s/\\\"finalizers\\\": \\[[^]]\\+\\]/\\\"finalizers\\\": []/\"   | kubectl replace --raw /api/v1/namespaces/$NS/finalize -f -\n</code></pre> <p>This page is a WIP, check back later for more contents</p>"},{"location":"misc/","title":"Misc","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"operating-systems/","title":"Operating Systems","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"operating-systems/linux/","title":"Operating Systems","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/","title":"Make your own Linux Distro From scratch","text":"<p>I'll call my distro name as: TiniLinux</p> <p>Welcome to TiniLinux, we will make a Linux Distro from scratch</p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/#theory","title":"Theory","text":"<p>To make a very tiny and simple Linux distro, we're going to need:</p> <ul> <li>Kernel</li> <li>User Space (in this case we use BusyBox)</li> <li>Bootloader (in this case we use Grub)</li> </ul> <pre><code>              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \n              \u2502     Power On       \u2502                     \n              \u2502                    \u2502                     \n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \n                        \u2502                                \n                        \u2502                                \n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \n              \u2502     BIOS/UEFI      \u2502                     \n              \u2502                    \u2502                     \n              \u2502       (POST)       \u2502                     \n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \n                        \u2502                                \n                        \u2502                                \n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \n              \u2502    Boot Device     \u2502                     \n              \u2502                    \u2502                     \n              \u2502  Hard Disk/CD/USB  \u2502                     \n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \n                        \u2502                                \n                        \u2502                                \n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \n              \u2502  Boot Loader(GRUB) \u2502                     \n              \u2502                    \u2502                     \n              \u2502  Load kernel and   \u2502                     \n              \u2502  initramfs to RAM  \u2502                     \n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \n                         \u2502                               \n                         \u2502                               \n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \n              \u2502       Kernel       \u2502                     \n              \u2502                    \u2502                     \n              \u2502 Execute /sbin/init \u2502                     \n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \n                         \u2502                               \n           (Live boot)   \u2502  (Boot from Hard disk)        \n           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \n           \u2502                            \u2502                \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \n\u2502   Init (initramfs) \u2502       \u2502  Init (initramfs)  \u2502      \n\u2502                    \u2502       \u2502  Mount Real rootfs \u2502      \n\u2502   Execute RunLevel \u2502       \u2502  from hard disk    \u2502      \n\u2502      programs      \u2502       \u2502  then switch_root  \u2502      \n\u2502                    \u2502       \u2502  exec /sbin/init   \u2502      \n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \n                                        \u2502                \n                                        \u2502                \n                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \n                             \u2502        Init        \u2502      \n                             \u2502                    \u2502      \n                             \u2502   Execute RunLevel \u2502      \n                             \u2502      programs      \u2502      \n                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \n                                        \u2502                \n                                        \u2502                \n                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \n                             \u2502  Systemd / OpenRC  \u2502      \n                             \u2502                    \u2502      \n                             \u2502   Execute System   \u2502      \n                             \u2502   Daemon programs  \u2502      \n                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \n\n(Drew with https://asciiflow.com/)\n</code></pre> <p>This applies to real world Linux distro as well (Debian, Ubuntu, Fedora,...)</p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/#steps","title":"Steps","text":"<p>This page is a WIP, check back later for more contents</p> <p>Here is a guide how to make a simple Linux Distro from scratch.</p> <ol> <li>Setup Environment </li> <li>Compile the kernel </li> <li>Compile Busybox </li> <li>Creating the initial ram filesystem (initramfs) </li> <li>Configuring the bootloader </li> <li>Package manager </li> <li>Docker </li> <li>Install to hard drive </li> <li>Appendix </li> </ol>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/#references","title":"References","text":"<ul> <li>https://www.youtube.com/watch?v=QlzoegSuIzg</li> <li>https://medium.com/@ThyCrow/compiling-the-linux-kernel-and-creating-a-bootable-iso-from-it-6afb8d23ba22</li> <li>https://medium.com/@GlobularOne/how-to-make-a-minimal-linux-distribution-from-source-code-5ff9b48dfc2</li> <li>https://gist.github.com/m13253/e4c3e3a56a23623d2e7e6796678b9e58</li> <li>https://kmahyyg.medium.com/tiny-image-dropbear-with-busybox-6f5b65a44dfb</li> <li>https://github.com/vmware/open-vm-tools/issues/696#issuecomment-1812710977 http://wiki.loverpi.com/faq:sbc:libre-aml-s805x-minimal-rootfs</li> <li>https://dariodip.medium.com/understanding-linux-containers-a-simple-recipe-7c24cc1137b4</li> </ul>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/1-setup-env/","title":"Setup Environment","text":""},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/1-setup-env/#1-setting-up-the-environment","title":"1. Setting up the environment:","text":"<p>Update the package list and install necessary tools:</p> <pre><code>sudo apt update\nsudo apt install build-essential git flex bison bc cpio libncurses5-dev libssl-dev libelf-dev\n\nexport WORKDIR=/home/${USER}/TiniLinux\n\nmkdir -p ${WORKDIR}/source                        # for linux kernel &amp; busybox source code\nmkdir -p ${WORKDIR}/build/amd64/initramfs         # for built kernel &amp; busybox\nmkdir -p ${WORKDIR}/build/amd64/uefi/boot/grub    # for making boot iso image\n</code></pre>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/2-kernel/","title":"Compile the kernel","text":""},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/2-kernel/#2-compile-the-kernel","title":"2. Compile the kernel:","text":"<p>Clone the Linux kernel source code:</p> <p><pre><code>cd ${WORKDIR}/source\n\ngit clone --depth=1 https://github.com/torvalds/linux.git\n\ncd linux\nmake defconfig\nmake menuconfig\n# Exit then save. The default config is good enough. (but nothing is stopping you from messing around it!)\n# NOTE: Fix Black Screen After Grub When Booting in UEFI\n# When booting in UEFI, after choosing your OS in grub, your screen might go blank and stay blank. This might indicate a problem in your kernel config\n# make menuconfig -&gt; press \"/\" button to search for config\n# Search for \"FB_EFI\" -&gt; Press \"1\" (the small number on the left of search result to quickly go to the config) -&gt; Press \"y\" -&gt; \"Esc Esc\" -&gt; \"1\" -&gt; \"y\"\n# Search for \"FRAMEBUFFER_CONSOLE\" -&gt; Press 1 -&gt; Press \"y\"\n\n# Some other recommended config to turn on:\n# IKCONFIG, IKCONFIG_PROC: read kernel .config through /proc/config.gz\n# EFIVAR_FS: mount EFI vars\n# OVERLAY_FS, BRIDGE, BRIDGE_NETFILTER, IP_NF_NAT, IP_NF_TARGET_MASQUERADE, VETH, IP_VS, NETFILTER_XT_MATCH_ADDRTYPE, NETFILTER_XT_MATCH_IPVS... (check more in docker section): to enable docker\n# HYPERV, HYPERV_KEYBOARD, HYPERV_NET, HYPERV_STORAGE, HYPERV_UTILS, (INPUT_MOUSEDEV, HID_HYPERV_MOUSE if enable GUI)\n# Save\n\n# to compile the kernel with all of your cores\nmake -j $(nproc)\n\ncp arch/x86/boot/bzImage ${WORKDIR}/build/amd64/uefi/boot/\n# cp arch/x86/boot/bzImage ${WORKDIR}/build/amd64/bios/boot/\n</code></pre> The compiled kernel image is copied to a directory named bootfiles.</p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/2-kernel/#kernel-modules","title":"Kernel modules","text":"<p>bzImage is the core of the kernel, which will be loaded to the memory from system boot to shutdown. Linux kernel support many features and drivers, you may not want to add them as built-in <code>[*]</code>, instead make them modules <code>[M]</code>, these can be loaded or unloaded after boot as hot plug when needed <pre><code># Copy compiled modules to a directory\nmake modules_install INSTALL_MOD_PATH=${WORKDIR}/build/amd64/kernel-modules/\n</code></pre></p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/3-busybox/","title":"Compile Busybox","text":""},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/3-busybox/#3-compile-busybox","title":"3. Compile Busybox:","text":"<p>BusyBox combines tiny versions of many common UNIX utilities into a single small executable.</p> <pre><code>cd ${WORKDIR}/source\n\ngit clone --depth=1 https://git.busybox.net/busybox\n\ncd busybox\nmake menuconfig\n# Now, enter the first sub-menu (Settings). Go down until you reach the section Build options. Select the Build static binary (no shared libs)\n# Optional: Go back to main menu. Scroll down until you find the Shells section. Two first options should be Choose which shell is aliased to 'sh' name and Choose which shell is aliased to 'bash' name. Choose each and tell BusyBox to alias sh to Ash and bash to Hush. You might also want to tweak some options but they are not required\n# Exit then save\nmake -j $(nproc)\nmake CONFIG_PREFIX=${WORKDIR}/build/amd64/initramfs install\n</code></pre> <p>The built Busybox binaries are installed into the <code>build/amd64/initramfs</code> directory. Now create a init script within initramfs to launch Busybox upon boot:</p> <pre><code>cd ${WORKDIR}/build/amd64/initramfs\n\ncat &lt;&lt;EOF &gt; init\n#!/bin/sh\n/bin/sh\nEOF\n\nchmod +x init\n</code></pre>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/3-busybox/#31-advance-advanced-init-and-login","title":"3.1. Advance (advanced init and login)","text":"<pre><code>cd ${WORKDIR}/build/amd64/initramfs\n\n# create some directories to give it a minimal Linux-like look\nmkdir -p {etc,dev,mnt,root,sys,proc,dev,run,tmp,var,home,etc/init.d}\n\n# /etc : We need to fill in a couple of files here\n\ncat &lt;&lt;EOF &gt; etc/inittab\n# https://github.com/brgl/busybox/blob/master/examples/inittab\n::sysinit:/etc/init.d/rcS\n\ntty1::respawn:/sbin/getty 0 tty1\ntty2::respawn:/sbin/getty 0 tty2\ntty3::respawn:/sbin/getty 0 tty3\ntty4::respawn:/sbin/getty 0 tty4\ntty5::respawn:/sbin/getty 0 tty5\ntty6::respawn:/sbin/getty 0 tty6\n\n# Enable these ttyS if you want to use serial (qemu -serial stdio)\n#ttyS0::respawn:/sbin/getty -L ttyS0 9600 vt100\n\n::restart:/sbin/init\n::ctrlaltdel:/sbin/reboot\n::shutdown:/bin/umount -a -r\n::shutdown:/sbin/swapoff -a\nEOF\n\n\ncat &lt;&lt;\\EOF &gt; etc/init.d/rcS\n#!/bin/sh\n\nmount -t sysfs    sysfs     -o nosuid,noexec,nodev    /sys\nmount -t proc     proc      -o nosuid,noexec,nodev    /proc\nmount -t devtmpfs devtmpfs  -o nosuid,mode=0755       /dev\nmount -t tmpfs    tmpfs     -o nosuid,nodev,mode=755  /run\nmkdir -p /dev/pts\nmount -t devpts   devpts    -o nosuid,gid=5,mode=620  /dev/pts\n\nmount -a\nmdev -s\n\nhostname tinilinux\nip link set lo up\necho 5 &gt; /proc/sys/kernel/printk\nsyslogd\n\ncat &lt;&lt;!\n\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\n\n  _____ _       _ _     _                  \n |_   _(_)_ __ (_) |   (_)_ __  _   ___  __\n   | | | | '_ \\| | |   | | '_ \\| | | \\ \\/ /\n   | | | | | | | | |___| | | | | |_| |&gt;  &lt; \n   |_| |_|_| |_|_|_____|_|_| |_|\\__,_/_/\\_\\\\\n\n\n\nWelcome to TiniLinux\n\n!\nEOF\n\n\nchmod +x etc/init.d/rcS\n\n\ncat &lt;&lt;EOF &gt; etc/hostname\ntinilinux\nEOF\n\n\ncat &lt;&lt;EOF &gt; etc/passwd\nroot::0:0:root:/root:/bin/bash\nEOF\n\n\ncat &lt;&lt;EOF &gt; etc/group\nroot:x:0:root\nEOF\n\n\ncat &lt;&lt;EOF &gt; etc/fstab\n# https://www.linuxfromscratch.org/lfs/view/10.0/chapter10/fstab.html\n# file system  mount-point  type     options                dump   fsck order\n\n# sysfs          /sys         sysfs    nosuid,noexec,nodev    0      0\n# proc           /proc        proc     nosuid,noexec,nodev    0      0\n# devtmpfs       /dev         devtmpfs nosuid,mode=0755       0      0\n# tmpfs          /run         tmpfs    nosuid,nodev,mode=755  0      0\n# devpts         /dev/pts     devpts   nosuid,gid=5,mode=620  0      0\n\n# /dev/sda2      /            ext4     defaults               0      1\n# /dev/sda1      /boot/efi    vfat     umask=0077             0      1\nEOF\n\n\ncat &lt;&lt;EOF &gt; init\n#!/bin/sh\nexec /linuxrc\nEOF\n\n\nchmod +x init\n</code></pre>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/3-busybox/#32-advance-network","title":"3.2. Advance (network)","text":"<pre><code>mkdir -p etc/network/if-up.d\nmkdir -p etc/network/if-pre-up.d\nmkdir -p etc/network/if-down.d\nmkdir -p etc/network/if-post-down.d\nmkdir -p var/run\nmkdir -p usr/share/udhcpc\n\n\ncat &lt;&lt;EOF &gt; etc/hosts\n127.0.0.1       localhost\n127.0.1.1       tinilinux\nEOF\n\n\ncat &lt;&lt;EOF &gt; etc/network/interfaces\n# enable dhcp for eth0 interface: https://wiki.alpinelinux.org/wiki/Udhcpc\nauto eth0\niface eth0 inet dhcp\n  hostname tinilinux\nEOF\n\n\ncat &lt;&lt;\\EOF &gt; usr/share/udhcpc/default.script\n#!/bin/ash\n\n# https://github.com/mschlenker/TinyCrossLinux/blob/master/patches/usr-share-udhcpc-default.script\n\nPATH=/bin:/sbin:/usr/bin:/usr/sbin\nexport PATH\n\n[ -z \"$1\" ] &amp;&amp; echo \"Error: should be called from udhcpc\" &amp;&amp; exit 1\n\nRESOLV_CONF=\"/etc/resolv.conf\"\n[ -n \"$broadcast\" ] &amp;&amp; BROADCAST=\"broadcast $broadcast\"\n[ -n \"$subnet\" ] &amp;&amp; NETMASK=\"netmask $subnet\"\n\ncase \"$1\" in\n  deconfig)\n    ifconfig $interface 0.0.0.0\n    ;;\n\n  renew|bound)\n    ifconfig $interface $ip $BROADCAST $NETMASK\n\n    if [ -n \"$router\" ] ; then\n      echo \"deleting routers\"\n      while route del default gw 0.0.0.0 dev $interface ; do\n        :\n      done\n\n      for i in $router ; do\n        route add default gw $i dev $interface\n      done\n    fi\n\n    echo -n &gt; $RESOLV_CONF\n    [ -n \"$domain\" ] &amp;&amp; echo search $domain &gt;&gt; $RESOLV_CONF\n    for i in $dns ; do\n      echo adding dns $i\n      echo nameserver $i &gt;&gt; $RESOLV_CONF\n    done\n    ;;\nesac\n\nexit 0\nEOF\n\n\nchmod +x usr/share/udhcpc/default.script\n\n# add line \"ifup eth0\" after \"ip link set lo up\":\nsed -i 's/ip link set lo up/ip link set lo up\\nifup eth0/g' etc/init.d/rcS\n</code></pre>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/3-busybox/#33-ssh-dropbear","title":"3.3. SSH (dropbear)","text":"<p>Build dropbear binary from source <pre><code>cd ${WORKDIR}/source\ngit clone --depth=1 https://github.com/mkj/dropbear.git\ncd dropbear\n./configure --enable-static\ncp src/default_options.h localoptions.h # update options if you want\nmake PROGRAMS=\"dropbear dbclient dropbearkey dropbearconvert scp\" MULTI=1 STATIC=1 strip\n</code></pre></p> <p>Copy dropbear binary to initramfs <pre><code>cp ${WORKDIR}/source/dropbear/dropbearmulti ${WORKDIR}/build/amd64/initramfs/usr/bin/\ncd ${WORKDIR}/build/amd64/initramfs/usr/bin/\nln -s dropbearmulti scp\nln -s dropbearmulti dropbearkey\nln -s dropbearmulti dropbearconvert\nln -s dropbearmulti dropbear\nln -s dropbearmulti ssh\nln -s dropbearmulti dbclien\n\ncd ${WORKDIR}/build/amd64/initramfs/\nmkdir -p {var/log,etc/default,etc/dropbear}\ntouch var/log/lastlog\n\ncat &lt;&lt;EOF &gt; etc/shells\n/bin/bash\n/bin/sh\nEOF\n</code></pre></p> <p>After boot, start dropbear with <pre><code>dropbear -EBR # log error on std error, allow blank password, create hostkey if required\n</code></pre></p> <p>or add to rcS <pre><code>sed -i 's/ifup eth0/ifup eth0 &amp;&amp; dropbear -RB/g' etc/init.d/rcS\n</code></pre></p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/3-busybox/#34-curl","title":"3.4. curl","text":"<p>I prefer curl over wget, so if you want to use curl <pre><code># check version and arch here: https://github.com/stunnel/static-curl/releases\ncurl -LO https://github.com/stunnel/static-curl/releases/download/8.6.0-1/curl-linux-x86_64-8.6.0.tar.xz\ntar -xvf curl-linux-x86_64-8.6.0.tar.xz\nrm curl-linux-x86_64-8.6.0.tar.xz\n\n# you may want to compress the binary: $ upx --brute curl\n\nmv curl usr/bin\n</code></pre></p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/4-initramfs/","title":"Creating the initial ram filesystem (initramfs)","text":""},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/4-initramfs/#4-creating-the-initial-ram-filesystem-initramfs","title":"4. Creating the initial ram filesystem (initramfs):","text":"<p>The find command is used to create a list of files within initramfs, and the cpio command archives them into a compressed image named initramfs.cpio.</p> <pre><code>cd ${WORKDIR}/build/amd64/initramfs/\nsudo chown -R root:root *\nfind . | cpio -o -H newc | gzip -9 &gt; ${WORKDIR}/build/amd64/uefi/boot/initramfs.cpio.gz\nsudo chown -R $USER:$(id -gn) *\n</code></pre> <p>Test the built kernel and initramfs <pre><code>sudo apt install qemu-system\n\nqemu-system-x86_64 -kernel bzImage -initrd initramfs.cpio.gz\nqemu-system-x86_64 -nographic -append console=ttyS0 -kernel bzImage -initrd initramfs.cpio.gz\n</code></pre></p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/5-bootloader/","title":"Configuring the bootloader","text":""},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/5-bootloader/#5-configuring-the-bootloader","title":"5. Configuring the bootloader:","text":""},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/5-bootloader/#51-use-grub-recommend","title":"5.1. Use grub (recommend)","text":"<p>We will use grub-mkrescue to create our bootable ISO. But before doing so, we have to know if our current host is booted with UEFI or BIOS. To do so, check if the folder /sys/firmware/efi exists on your system or not. If it does, your computer uses UEFI otherwise it\u2019s BIOS.</p> <p>So why knowing this is important? The grub-mkrescue uses the currently installed grub stuff to create the ISO image. This means that if your operating system is booted in BIOS, the chances are that the ISO created from grub-mkrescue does not support UEFI at all. In some cases, UEFI motherboards support booting BIOS images using CMS. But that\u2019s not always the case. If you want to make images for BIOS from UEFI host or vice versa, I suggest you to create a Debian virtual machine in VirtualBox. VirtualBox supports both BIOS and UEFI in it\u2019s motherboard settings. After choosing the appropriate one, install Debian (net install is sufficient) and move the folder which contains boot and grub folders to virtual machine</p> <p>If you use grub in wsl2: https://github.com/Microsoft/WSL/issues/807#issuecomment-356697269</p> <p>Create a folder somewhere with any name you want. I name it iso. Then create a folder called boot in it and inside boot create a folder called grub. Then copy bzImage and initramfs.cpio.gz into boot folder.</p> <pre><code>sudo apt install xorriso mtools\ncd ${WORKDIR}/build/amd64/\n</code></pre> <p>UEFI <pre><code>cat &lt;&lt;EOF &gt; uefi/boot/grub/grub.cfg\nset default=0\nset timeout=2\n# Load EFI video drivers. This device is EFI so keep the video mode while booting the linux kernel.\ninsmod efi_gop\ninsmod font\nif loadfont /boot/grub/fonts/unicode.pf2\nthen\n  insmod gfxterm\n  set gfxmode=auto\n  set gfxpayload=keep\n  terminal_output gfxterm\nfi\nmenuentry 'TiniLinux' --class os {\n  insmod gzio\n  insmod part_msdos\n  linux /boot/bzImage\n  initrd /boot/initramfs.cpio.gz\n}\nEOF\n\ngrub-mkrescue -o tinilinux-amd64-uefi.iso uefi\n</code></pre></p> <p>BIOS <pre><code>cat &lt;&lt;EOF &gt; bios/boot/grub/grub.cfg\nset default=0\nset timeout=2\nmenuentry 'TiniLinux' --class os {\n  insmod gzio\n  insmod part_msdos\n  linux /boot/bzImage\n  initrd /boot/initramfs.cpio.gz\n}\nEOF\n\ngrub-mkrescue -o tinilinux-bios-uefi.iso bios/\n</code></pre></p> <p>Note: uefi iso can boot with both uefi and bios</p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/5-bootloader/#52-use-syslinux","title":"5.2. Use syslinux","text":"<p>The syslinux package is installed to provide the bootloader. A blank disk image is created and formatted with a FAT filesystem. The kernel image and initramfs are copied to the disk image.</p> <pre><code># using syslinux\nsudo apt install syslinux dosfstools\ndd if=/dev/zero of=boot bs=1M count=50\nmkfs -t fat boot\nsyslinux boot\nmkdir m\nsudo mount boot m\ncp bzImage init.cpio m\numount m\n</code></pre> <p>Test: <pre><code>qemu-system-x86_64 boot\n</code></pre></p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/5-bootloader/#booting-the-distro","title":"Booting the distro:","text":"<p>The iso file now can be used with VirtualBox or VMWare or burn to USB/CD</p> <p>From here, the basic steps of making a Linux distro from scatch are complete</p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/6-package-manager/","title":"Install a package manager (apk)","text":""},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/6-package-manager/#install-a-package-manager-apk","title":"Install a package manager (apk)","text":"<p>We will use <code>apk</code> (Alpine package manager) from Alpine Linux because it's very lightweight and designed to run on RAM (as Alpine Linux)</p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/6-package-manager/#pre-install-in-the-iso-file","title":"Pre-install in the iso file","text":"<pre><code>cd ${WORKDIR}/build/amd64/initramfs\n\nwget https://gitlab.alpinelinux.org/api/v4/projects/5/packages/generic//v2.14.0/x86_64/apk.static\n\nsudo chroot .\n\ncp /bin/busybox /bin/busybox-bak # backup original busybox as apk add will replace it\ncat &lt;&lt;EOF &gt; /etc/resolv.conf\nnameserver 8.8.8.8\nEOF\nmv apk.static apk\nchmod +x apk\nmv apk /usr/bin/apk\nmkdir -p /lib/apk/db/\nmkdir -p /etc/apk/\ntouch /etc/apk/world\ncat &lt;&lt;EOF &gt; /etc/apk/repositories\nhttp://dl-cdn.alpinelinux.org/alpine/v3.19/main\nhttp://dl-cdn.alpinelinux.org/alpine/v3.19/community\nEOF\napk add --allow-untrusted --no-cache ca-certificates alpine-keys\ncat &lt;&lt;EOF &gt; /etc/apk/repositories\nhttps://dl-cdn.alpinelinux.org/alpine/v3.19/main\nhttps://dl-cdn.alpinelinux.org/alpine/v3.19/community\nEOF\nmv -f /bin/busybox-bak /bin/busybox\nrm -rf /lib/apk/exec\nrm -rf /lib/apk/db/lock\nrm -rf /var/cache/apk/*\n\nexit\n\nsudo rm -rf root/.bash_history\nsudo rm -rf root/.hush_history\n</code></pre>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/6-package-manager/#use-apk","title":"Use apk","text":"<p>After booted from the iso, we can use apk normally <pre><code>apk update\n\napk add bash wget coreutils\napk add python3\n</code></pre></p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/6-package-manager/#alpine-linux-utilities","title":"Alpine Linux utilities","text":"<p>Since we're using apk, it comes with a lot of useful utilities thanks to Alpine Linux <pre><code>apk add alpine-conf\n# https://wiki.alpinelinux.org/wiki/Alpine_setup_scripts\n\nsetup-sshd\nsetup-desktop\n</code></pre></p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/7-docker/","title":"Install docker","text":""},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/7-docker/#install-docker","title":"Install docker","text":""},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/7-docker/#check-kernel-config","title":"Check kernel config","text":"<p>In order to run docker, some kernel modules needs to be enabled. If you already enabled them, skip this part <pre><code># script to check kernel config for docker support (note: enable CONFIG_IKCONFIG + CONFIG_IKCONFIG_PROC from kernel make menuconfig first)\n# wget https://github.com/moby/moby/raw/master/contrib/check-config.sh\n# chmod +x check-config.sh\n# ./check-config.sh\n</code></pre></p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/7-docker/#install-by-package-manager-apk","title":"Install by package manager (apk)","text":"<pre><code>mkdir -p /lib/modules\n\napk add docker iptables-legacy\nrm /sbin/iptables\ncp /sbin/iptables-legacy /sbin/iptables\nrm /sbin/iptables-save\ncp /sbin/iptables-legacy-save /sbin/iptables-save\nrm /sbin/iptables-restore\ncp /sbin/iptables-legacy-restore /sbin/iptables-restore\n</code></pre>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/7-docker/#or-install-by-binary","title":"Or: Install by binary","text":"<p>TODO: add guide to install iptables  <pre><code>wget https://download.docker.com/linux/static/stable/x86_64/docker-26.0.0.tgz\ntar xzvf docker-26.0.0.tgz\ncp docker/* /usr/bin/\n</code></pre></p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/7-docker/#use-docker","title":"Use docker","text":"<p>Before running dockerd, cgroupfs needs to be mounted <pre><code># copy the cgroup2-mount.sh from hack/docker\nwget https://gist.githubusercontent.com/haoict/770e65bb718ddac6d10cbd7e0d39fcf7/raw/7d40ced18bb202cf82f25765547581224c5d609d/cgroup2-mount.sh\nchmod +x cgroup2-mount.sh\n./cgroup2-mount.sh\n</code></pre></p> <p>Start dockerd <pre><code>DOCKER_RAMDISK=true dockerd &amp; #(if run with live boot) OR\ndockerd &amp; #(if installed to hard disk)\n</code></pre></p> <p>Now you can use docker normally <pre><code>docker run -d --rm -p 8000:8000 haoict/hello-world\n</code></pre></p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/","title":"Install to hard drive","text":""},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/#install-to-hard-drive","title":"Install to hard drive","text":"<p>At this stage, everything is basically complete, you have a complete live boot ISO. You may want to install it to hard drive and use as or normal Operating System.</p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/#make-an-early-boot-initramfs","title":"Make an early boot initramfs","text":"<p>First, we have to have a new fresh early-boot initramfs. This early-boot initramfs is different from live boot initramfs as after installed to hard disk, when you boot, the bootloader will load the kernel and this early-boot initramfs, it will mount the hard drive (the main root filesystem) to /mnt/.root, switch_root to it, and then call /sbin/init again. After that the system will be init from root file system from the hard disk</p> <p>Boot Loader -&gt; Load Kernel + Load initramfs -&gt; switch_root to rootfs from hard disk</p> <pre><code>## Update initramfs for boot from hard drive, from your main PC:\n# if not yet have the initramfs-boot\n# cd ${WORKDIR}/source/busybox/\n# make CONFIG_PREFIX=${WORKDIR}/build/amd64/initramfs-boot install\ncd ${WORKDIR}/build/amd64/initramfs-boot\nmkdir dev proc sys run\n\ncat &lt;&lt;\\EOF &gt; init\n#!/bin/sh\n\nROOT=\"/mnt/.root\"\nROOT_DEV=\"/dev/sda2\"\n\necho \"init from initramfs\"\n\n# mount temporary filesystems\nmount -n -t devtmpfs devtmpfs /dev\nmount -n -t proc     proc     /proc\nmount -n -t sysfs    sysfs    /sys\nmount -n -t tmpfs    tmpfs    /run\n\n# mount new root\n[ -d ${ROOT} ] || mkdir -p ${ROOT}\nmount ${ROOT_DEV} ${ROOT}\n\n# switch to new rootfs and exec init\ncd ${ROOT}\nexec switch_root . \"/sbin/init\" \"$@\"\nEOF\n\nchmod +x init\n\n# rebuild initramfs\nmkdir ../initramfs/boot/\nsudo chown -R root:root * &amp;&amp; find . | cpio -o -H newc | gzip -9 &gt; ../initramfs/boot/initramfs.cpio.gz &amp;&amp; sudo chown -R $USER:$(id -gn) *\ncd ${WORKDIR}/build/amd64/initramfs\ncp ${WORKDIR}/source/linux/arch/x86/boot/bzImage ${WORKDIR}/build/amd64/initramfs/boot/\ncp -r ${WORKDIR}/build/amd64/kernel-modules/lib/modules ${WORKDIR}/build/amd64/initramfs/lib\n\n### Build the iso again and start booting from it, proceed to the next step\ncd ${WORKDIR}/build/amd64/initramfs\n\nsudo chown -R root:root * &amp;&amp; find . | cpio -o -H newc | gzip -9 &gt; ${WORKDIR}/build/amd64/uefi/boot/initramfs.cpio.gz &amp;&amp; sudo chown -R $USER:$(id -gn) *\ngrub-mkrescue -o ${WORKDIR}/build/amd64/tinilinux-amd64-uefi.iso ${WORKDIR}/build/amd64/uefi\n</code></pre>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/#start-installing-to-hard-drive","title":"Start installing to hard drive","text":"<p>Now boot using the iso, after booted from the iso: <pre><code>apk add --allow-untrusted --no-cache ca-certificates alpine-keys\napk add --no-cache bash wget lsblk cfdisk grub grub-bios grub-efi dosfstools e2fsprogs rsync efibootmgr\n\n\ncat &lt;&lt;EOF &gt; /etc/group\nroot:x:0:\ndaemon:x:1:\nbin:x:2:\nsys:x:3:\nadm:x:4:syslog\ntty:x:5:\ndisk:x:6:\nlp:x:7:\nmail:x:8:\nnews:x:9:\nuucp:x:10:\nman:x:12:\nproxy:x:13:\nkmem:x:15:\ndialout:x:20:\nfax:x:21:\nvoice:x:22:\ncdrom:x:24:\nfloppy:x:25:\ntape:x:26:\nsudo:x:27:\naudio:x:29:\ndip:x:30:\nwww-data:x:33:\nbackup:x:34:\noperator:x:37:\nlist:x:38:\nirc:x:39:\nsrc:x:40:\ngnats:x:41:\nshadow:x:42:\nutmp:x:43:\nvideo:x:44:\nsasl:x:45:\nplugdev:x:46:\nstaff:x:50:\ngames:x:60:\nusers:x:100:\nnogroup:x:65534:\nEOF\n\n\n# create partition\n# /dev/sda1: for boot   (must be vfat or fat32), 100MB is ok\n# /dev/sda2: for rootfs (can be ext4), the rest of disk storage\ncfdisk\n# choose GPT for UEFI or dos for BIOS boot\n# type can be default: Linux filesystem\n# remember to [Write] all /dev/sda* before [Quit]\n\nmdev -s\n\n# format partition with the correct type\nmkfs.fat -F32 /dev/sda1\nmkfs.ext4 /dev/sda2\n\n# mount disk and install grub\nmount /dev/sda2 /mnt\n\n## use rsync to copy the entire root filesystem to another location\nrsync -aAXv /* /mnt --exclude={/dev/*,/proc/*,/sys/*,/tmp/*,/run/*,/mnt/*,/media/*,/lost+found}\n\nmkdir -p /mnt/boot/efi\nmount /dev/sda1 /mnt/boot/efi\n\nmount --bind /dev/ /mnt/dev/\nmount --bind /proc/ /mnt/proc/\nmount --bind /sys/ /mnt/sys/\n\nchroot /mnt\n\nmount -t efivarfs efivarfs /sys/firmware/efi/efivars\n\ngrub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=TiniLinux-UEFI #--bootloader-id=GRUB --no-nvram --removable\n\n# then add this line to /etc/default/grub\ncat &lt;&lt;\\EOF &gt; /etc/default/grub\nGRUB_DISTRIBUTOR=\"TiniLinux\"\nGRUB_TIMEOUT=2\nGRUB_DISABLE_SUBMENU=y\nGRUB_DISABLE_RECOVERY=true\nGRUB_CMDLINE_LINUX_DEFAULT=\"quiet\"\nGRUB_CMDLINE_LINUX=\"\"\nEOF\n\n\n#check disk id: blkid\n#/dev/sda2: UUID=\"4c8d1658-283e-4a07-9ab6-7efd4623e094\" TYPE=\"ext4\"\n#/dev/sda1: UUID=\"8CE4-73DF\" TYPE=\"vfat\"\n\n# then add this line to /etc/grub.d/40_custom\ncat &lt;&lt;\\EOF &gt;&gt; /etc/grub.d/40_custom\nmenuentry \"TiniLinux\" {\n  set root=(hd0,gpt2)\n  echo \"Loading kernel...\"\n  linux /boot/bzImage root=/dev/sda2 ro quiet splash\n  echo \"Loading initramfs...\"\n  initrd /boot/initramfs.cpio.gz\n}\nEOF\n\n\nmv /etc/grub.d/30_uefi-firmware /etc/grub.d/50_uefi-firmware\n\n\nupdate-grub\n\n# check grub.cfg for the added menuentry\ncat /boot/grub/grub.cfg\n\nexit\numount /mnt/proc /mnt/sys/firmware/efi/efivars /mnt/sys /mnt/dev\nmkdir -p /mnt/dev/pts\numount /dev/sda1\numount /dev/sda2\nexit\n</code></pre></p> <p>Remove live boot CD or USB Now try boot from hard disk if it fail, from grub menu press e to edit the entry or press c to enter command line <pre><code>ls\nset root=(hd0,gpt2)\nlinux /boot/bzImage root=/dev/sda2\ninitrd /boot/initramfs.cpio.gz\nboot\n</code></pre> Now we can boot, after booted, run update-grub again Done</p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/#post-installation","title":"Post installation","text":"<p>After installation, you can do these steps to make your OS more Linux-like OS</p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/#rdd","title":"rdD","text":"<p>Contrary with rcS, this script will be excecuted when the system shutdown or restart <pre><code># add this line before any ::shutdown lines in /etc/inittab\n::shutdown:/etc/rcD\n\ncat &lt;&lt;\\EOF &gt;&gt; /etc/rcD\n#!/bin/sh\nifdown eth0\nEOF\nchmod +x /etc/rcD\n</code></pre></p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/#enable-syslogd","title":"Enable syslogd","text":"<pre><code># Add to /etc/init.d/rcS\nsyslogd\n\n# Now you can view system log\ncat /var/log/messages\n</code></pre>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/#users","title":"Users","text":"<p>Create normal users <pre><code>apk add shadow\ntouch /etc/shadow\nchmod 640 /etc/shadow\n\naddgroup haoict\nadduser haoict -G haoict\n\naddgroup -g 27 sudo\napk add sudo\nvi /etc/sudoers\n# uncomment %sudo   ALL=(ALL:ALL) ALL\naddgroup haoict sudo\n\nsudo chmod 666 /dev/urandom\nsudo chmod 666 /dev/null\nsudo chmod -R 777 /tmp\n</code></pre></p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/#disable-ipv6","title":"Disable ipv6","text":"<pre><code>echo 0 &gt; /proc/sys/net/ipv6/conf/all/autoconf\necho 0 &gt; /proc/sys/net/ipv6/conf/all/accept_ra\necho 1 &gt; /proc/sys/net/ipv6/conf/all/disable_ipv6\n</code></pre>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/#patch-the-kernel","title":"Patch the kernel","text":"<p>Sometimes you may want to add some features or driver modules, you can compile the kernel again and copy it to <code>/boot/</code> and <code>/lib/modules</code></p> <pre><code>cd ${WORKDIR}/source/linux\nmake menuconfig\nmake -j $(nproc)\nmake modules_install INSTALL_MOD_PATH=${WORKDIR}/build/amd64/kernel-modules/\n\nrsync -lr ${WORKDIR}/build/amd64/kernel-modules/lib/modules root@192.168.1.131:/lib/\nscp ${WORKDIR}/source/linux/arch/x86/boot/bzImage root@192.168.1.131:/boot/\n\n# to load kernel module\nmodprobe &lt;module_name&gt;\n\n# list loadable modules\nfind /lib/modules/$(uname -r) -type f -name '*.ko' \ncat /lib/modules/$(uname -r)/modules.alias #  (with alias)\n\n# list loaded modules\nlsmod\n</code></pre>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/99-appendix/","title":"Appendix","text":""},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/99-appendix/#cross-compilation-arm64","title":"Cross compilation (arm64)","text":"<pre><code>sudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu\n#make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig\nmake ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig\nmake ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j 8\nmake ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- CONFIG_PREFIX=${WORKDIR}/build/arm64/initramfs install\n\n# follow the same steps to create initramfs.cpio.gz\ncd ${WORKDIR}/build/arm64/initramfs\n\nsudo chown -R root:root * &amp;&amp; find . | cpio -o -H newc | gzip -9 &gt; ${WORKDIR}/build/arm64/uefi/boot/initramfs.cpio.gz &amp;&amp; sudo chown -R $USER:$(id -gn) * \n\n# test\n## ref: https://gist.github.com/billti/d904fd6124bf6f10ba2c1e3736f0f0f7\n## list cpu: qemu-system-aarch64 -M virt -cpu help\nqemu-system-aarch64 -m 2048 -cpu cortex-a72 -smp 4 -M virt -nographic -kernel Image -initrd initramfs.cpio.gz\n</code></pre> <p>Make the iso and boot?? TBD (I haven't figured out yet, beside a Raspberry Pi which is running well and I don't want to mess with it, I don't have any spare arm64 board)</p>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/99-appendix/#install-gui-x11","title":"Install GUI (X11)","text":"<pre><code>apk add alpine-conf\n# setup mdev: https://wiki.alpinelinux.org/wiki/Mdev\nsetup-devd udev # or apk add busybox-mdev-openrc\n\nsetup-desktop xfce\nrc-update del lightdm\nrc-status # check openrc\n\napk add xterm\napk add xf86-video-vmware xf86-video-fbdev xf86-video-vesa\n\n/sbin/openrc sysinit\n/sbin/openrc boot\n\nstartx # or startxfce4 or xinit xfce4-session\n# for gnome: xinit gnome-session\n# for mate: xinit mate-session\n# for plasma: xinit plasma_session\n\n# extra\napk add open-vm-tools xf86-input-vmmouse\n/etc/init.d/open-vm-tools start\nstartx\n</code></pre>"},{"location":"operating-systems/linux/make-your-own-linux-distro-from-scratch/99-appendix/#all-in-one-command-for-built-test","title":"All in one command for built &amp; test","text":"<pre><code>cd ${WORKDIR}/build/amd64/initramfs\n\nsudo chown -R root:root * &amp;&amp; find . | cpio -o -H newc | gzip -9 &gt; ${WORKDIR}/build/amd64/uefi/boot/initramfs.cpio.gz &amp;&amp; sudo chown -R $USER:$(id -gn) *\ngrub-mkrescue -o ${WORKDIR}/build/amd64/tinilinux-amd64-uefi.iso ${WORKDIR}/build/amd64/uefi\n</code></pre>"},{"location":"operating-systems/windows/","title":"Operating Systems","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"operating-systems/windows/build-msdos-4.00-from-source/","title":"How to compile the MS-DOS from Microsoft open source","text":""},{"location":"operating-systems/windows/build-msdos-4.00-from-source/#overview","title":"Overview","text":"<p>Recently Microsoft just opened source MS-DOS 4.0 under MIT license. Let's try to compile it.  </p> <p>MS-DOS github: https://github.com/microsoft/MS-DOS</p> <p>More info: https://cloudblogs.microsoft.com/opensource/2024/04/25/open-sourcing-ms-dos-4-0/</p>"},{"location":"operating-systems/windows/build-msdos-4.00-from-source/#prepare","title":"Prepare","text":""},{"location":"operating-systems/windows/build-msdos-4.00-from-source/#compiling-environment","title":"Compiling Environment","text":"<p>Since the toolchain shipped with the source code in the same repository are 16 bit binaries. We can't run it in modern Windows 10 or 11. We need to run it under a 16 bit Virtual machine or emulator. It can be FreeDOS (VM) or DOSBox (emulator). We'll use DOSBox because it's easy to setup and run directly in Windows 10/11.</p> <p>Download and setup DOSBox: https://www.dosbox.com/download.php?main=1</p> <p></p> <p>You can press Ctrl+F12 to increase CPU speed, around 18000-20000 cycles is a good number</p>"},{"location":"operating-systems/windows/build-msdos-4.00-from-source/#obtain-the-source-code","title":"Obtain the source code","text":"<p>Download the source code from MS-DOS Github repo: https://github.com/microsoft/MS-DOS/archive/refs/heads/main.zip and then extract it</p> <p>or clone it with git clone command <pre><code>git clone --depth=1 https://github.com/microsoft/MS-DOS.git\n</code></pre></p> <p></p>"},{"location":"operating-systems/windows/build-msdos-4.00-from-source/#mount-the-source-code-directory-to-dosbox","title":"Mount the source code directory to DOSBox","text":"<p>In order to use files from the host computer (Windows 10/11) in DOSBox, we have to mount it. In DOSBox Run this command: <pre><code># mount source code to driver D\nmount d c:\\Users\\Hao\\Download\\MS-DOS-main\\v4.0\n\n# go to the source code dir\nD:\ncd SRC\n\n# verify\nDIR\n</code></pre></p> <p>The command will mount the directory <code>C:\\Users\\Hao\\Download\\MS-DOS-main\\v4.0</code> (host computer) to driver <code>D:</code> of DOSBox. Remember to change <code>C:\\Users\\Hao\\Download\\MS-DOS-main\\v4.0</code> with your path in your computer</p> <p></p>"},{"location":"operating-systems/windows/build-msdos-4.00-from-source/#compiling","title":"Compiling","text":""},{"location":"operating-systems/windows/build-msdos-4.00-from-source/#first-try","title":"First try","text":"<p>From here, we can try to compile it. Run: <pre><code>RUNME.BAT\n</code></pre> it will print the guide how to build it. You can open <code>RUNME.BAT</code> from the host computer to see the whole file content</p> <p></p> <p>Basically there're 3 steps:</p> <ul> <li>Run <code>SETENV.BAT</code> to setup environment</li> <li>Run <code>NMAKE</code> command to start building</li> <li>Run <code>CPY outputDir</code> to copy the built files to the output folder</li> </ul> <p>Let's try it</p> <p><pre><code>SETENV.BAT\n\nNNAME\n</code></pre> </p> <p>There are errors due to file encoding (need to change to ASCII) and line ending differences between linux and DOS (need to change from LF to CRLF), we have to patch it. You can try to do it yourself or use my script to do it quickly.  </p>"},{"location":"operating-systems/windows/build-msdos-4.00-from-source/#patch-the-source-code","title":"Patch the source code","text":"<p>Open PowerShell from host computer, <code>cd</code> to the <code>MS-DOS-main\\v4.0\\src</code> directory and run these commands one by one <pre><code>(Get-Content \"SETENV.BAT\") -replace \"tools\\\\lib\",\"tools\\bld\\lib\" | Set-Content -Path \"SETENV.BAT\" -Encoding ASCII\n(Get-Content \"SETENV.BAT\") -replace \"tools\\\\inc\",\"tools\\bld\\inc\" | Set-Content -Path \"SETENV.BAT\" -Encoding ASCII\n\n(Get-Content \"MAPPER/GETMSG.ASM\") -replace \"\\xEF\\xBF\\xBD|\\xC4\\xBF|\\xC4\\xB4\",\"#\" | Set-Content -Path \"MAPPER/GETMSG.ASM\" -Encoding ASCII\n(Get-Content \"SELECT/SELECT2.ASM\") -replace \"\\xEF\\xBF\\xBD|\\xC4\\xBF|\\xC4\\xB4\",\"#\" | Set-Content -Path \"SELECT/SELECT2.ASM\" -Encoding ASCII\n(Get-Content \"SELECT/USA.INF\") -replace \"\\xEF\\xBF\\xBD|\\xC4\\xBF|\\xC4\\xB4\",\"#\" | Set-Content -Path \"SELECT/USA.INF\" -Encoding ASCII\n\nGet-ChildItem -Path . -Filter *.BAT -Recurse -File | ForEach-Object {\n    echo $_.FullName\n    (Get-Content -raw $_.FullName) -replace \"(?&lt;!`r)`n\",\"`r`n\" | Set-Content -nonewline -Encoding ASCII $_.FullName\n}\nGet-ChildItem -Path . -Filter *.ASM -Recurse -File | ForEach-Object {\n    echo $_.FullName\n    (Get-Content -raw $_.FullName) -replace \"(?&lt;!`r)`n\",\"`r`n\" | Set-Content -nonewline -Encoding ASCII $_.FullName\n}\nGet-ChildItem -Path . -Filter *.SKL -Recurse -File | ForEach-Object {\n    echo $_.FullName\n    (Get-Content -raw $_.FullName) -replace \"(?&lt;!`r)`n\",\"`r`n\" | Set-Content -nonewline -Encoding ASCII $_.FullName\n}\nGet-ChildItem -Path . -Filter ZERO.DAT -Recurse -File | ForEach-Object {\n    echo $_.FullName\n    (Get-Content -raw $_.FullName) -replace \"(?&lt;!`r)`n\",\"`r`n\" | Set-Content -nonewline -Encoding ASCII $_.FullName\n}\nGet-ChildItem -Path . -Filter LOCSCR -Recurse -File | ForEach-Object {\n    echo $_.FullName\n    (Get-Content -raw $_.FullName) -replace \"(?&lt;!`r)`n\",\"`r`n\" | Set-Content -nonewline -Encoding ASCII $_.FullName\n}\n</code></pre></p> <p> </p> <p>Now let's build again <pre><code>cd D:\\SRC\nSETENV.BAT\nNMAKE\n</code></pre></p> <p>Tada!!! The build is successful. \ud83c\udf89\ud83c\udf89</p> <p></p>"},{"location":"operating-systems/windows/build-msdos-4.00-from-source/#runing-the-compiled-ms-dos-40","title":"Runing the compiled MS-DOS 4.0","text":"<p>Now we can copy built files to the output directory. Run: <pre><code># make output dir\nmkdir D:\\BIN\n\nCPY D:\\BIN\n</code></pre></p> <p></p> <p>Now we're inside the built directory of the DOS 4.0, we can run the new built <code>COMMAND.COM</code> shell</p> <pre><code>cd D:\\BIN\n\n# set DOSBox version to 4\nver set 4\n\n# check version\nver\n# -&gt; you can see printed version is 4.00 from DOSBox\n# \"DOSBox version 0.74-3. Reported DOS version 4.00.\"\n\n# now call COMMAND.COM from D:\\BIN directory to swith shell\n\nCOMMAND.COM\n\n# check version, again\nver\n# -&gt;now  you can see printed version is 4.00 from the new shell\n# \"MS-DOS Version 4.00\"\n</code></pre> <p>That's it, now we're running MS-DOS 4.00 from the binaries we just built. Congratulations!!</p> <p></p>"},{"location":"operating-systems/windows/build-msdos-4.00-from-source/#whats-next","title":"What's next?","text":"<p>From here, you can try to build a bootable image and boot it with Virtual Box or VMWare. Goodluck! </p>"},{"location":"operating-systems/windows/wsl2-guide/","title":"WSL2 Guide","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"operating-systems/windows/wsl2-guide/#add-usb-drive-to-wsl","title":"Add USB Drive to WSL","text":"<p>Microsoft has a doccumentation of how to connect USB devices to WSL (https://learn.microsoft.com/en-us/windows/wsl/connect-usb), but it's essentially just passthrough usb bus, we can't mount the usb device yet because the WSL Linux kernel doesn't support USB mass storage. So we have to rebuild WSL Linux kernel, let's get started</p>"},{"location":"operating-systems/windows/wsl2-guide/#rebuild-the-wsl-linux-kernel","title":"Rebuild the WSL Linux kernel","text":"<p>Go to WSL-Linux-Kernel github releases, download the latest source code (.tar.gz): https://github.com/microsoft/WSL2-Linux-Kernel/releases</p> <p>From inside a WSL instance, run: <pre><code># First, install build dependencies\nsudo apt install build-essential flex bison dwarves libssl-dev libelf-dev\n\n# Download source code\nwget https://github.com/microsoft/WSL2-Linux-Kernel/archive/refs/tags/linux-msft-wsl-5.15.153.1.tar.gz\ntar -zxvf linux-msft-wsl-5.15.153.1.tar.gz\ncd WSL2-Linux-Kernel-linux-msft-wsl-5.15.153.1\n\n# Get current kernel config\nsudo cp /proc/config.gz .\nsudo gunzip config.gz\nsudo mv config .config\n\n# update config to add USB Mass Storage support\nmake menuconfig\n# Go to Device Drivers -&gt; USB support -&gt; USB Mass Storage support. Press y to build as built-in [*]\nmake -j$(nproc)\n\n# Copy the built kernel image to Windows, change the path (/mnt/c/...) wherever you want\ncp arch/x86_64/boot/bzImage /mnt/c/Users/Hao/.\n</code></pre></p>"},{"location":"operating-systems/windows/wsl2-guide/#update-wslconfig-to-use-our-kernel-image","title":"Update .wslconfig to use our kernel image","text":"<p>In Windows, go to your home folder (C:\\Users\\Hao), create a file named <code>.wslconfig</code> if not exist</p> <p>Edit the file, add these line <pre><code>[wsl2]\nkernel = C:\\\\Users\\\\Hao\\\\bzImage\n</code></pre></p> <p>Note: other <code>.wslconfig</code> settings can be found here: https://learn.microsoft.com/en-us/windows/wsl/wsl-config#global-configuration-options-with-wslconfig</p> <p>Now restart wsl, open powershell and run <pre><code>wsl --shutdown\nwsl\n</code></pre></p>"},{"location":"operating-systems/windows/wsl2-guide/#attach-the-usb-drive-to-wsl","title":"Attach the USB drive to WSL","text":"<p>From here, you can follow the MS's documentation above (https://learn.microsoft.com/en-us/windows/wsl/connect-usb)</p> <p>Basically run: <pre><code># install usbipd\nwinget install --interactive --exact dorssel.usbipd-win\n\n# list usb\nusbipd list\n\n# You will see output like this, in this case, BUSID 2-3 is my connected usb\n#Connected:\n#BUSID  VID:PID    DEVICE                                                        STATE\n#1-1    05ac:8233  NCM Composite Device                                          Not shared\n#1-3    05ac:8262  USB Input Device                                              Not shared\n#2-3    14cd:1212  USB Mass Storage Device                                       Not shared\n\n# Bind the bus first\nusbipd bind --busid 2-3\n\n# Attach to WSL\nusbipd attach --wsl --busid 2-3\n</code></pre></p> <p>Now inside WSL instance, you can use it, some example commands <pre><code>lsusb\nlsblk\nmount -t ext4 /dev/sdb1 /mnt/usb\n</code></pre></p> <p>Once you are done using the device in WSL, you can detach it, run this command inside powershell <pre><code>usbipd detach --busid 2-3\n</code></pre></p>"},{"location":"software-engineering/","title":"Software Engineering","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"vi/","title":"Home","text":"$ make do"},{"location":"vi/#welcome-to-haoict-techblog","title":"Welcome to Haoict TechBlog","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"vi/#hot-articles","title":"Hot articles:","text":"<ul> <li>How to compile the MS-DOS from Microsoft open source</li> <li>Make your own Linux Distro From scratch</li> <li>Create a Kubernetes cluster (mainline kubernetes)</li> <li>Create a Kubernetes cluster (k3s)</li> <li>GitOps Development</li> </ul>"},{"location":"vi/faqs/","title":"Frequently Asked Questions","text":""},{"location":"vi/devops/","title":"Devops","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"vi/devops/cicd/argocd/","title":"Devops","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"vi/devops/cicd/jenkins/","title":"Devops","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"vi/devops/cicd/gitops-development/","title":"Git Ops Development","text":""},{"location":"vi/devops/cicd/gitops-development/#introduction","title":"Introduction","text":"<p>GitOps is a modern approach to continuous delivery and operational management that uses Git as the single source of truth for declarative infrastructure and applications. It automates deployment processes, ensuring consistency, reliability, and transparency.</p> <p></p>"},{"location":"vi/devops/cicd/gitops-development/#key-concepts-of-gitops","title":"Key Concepts of GitOps","text":"<ol> <li>Declarative Infrastructure: Define infrastructure and application states using configuration files.</li> <li>Version Control: Store and track configuration files in Git repositories.</li> <li>Automated Deployment: Use CI/CD pipelines to apply changes from Git to the environment.</li> <li>Observability and Monitoring: Monitor and ensure the deployed state matches the desired state.</li> </ol>"},{"location":"vi/devops/cicd/gitops-development/#benefits-of-gitops","title":"Benefits of GitOps","text":"<ul> <li>Consistency and Reliability: By using Git as the single source of truth, GitOps ensures that the deployed state is consistent with the desired state, reducing configuration drift and human errors.</li> <li>Auditability and Compliance: All changes are tracked in Git, providing a clear audit trail and facilitating compliance with regulatory requirements.</li> <li>Faster Recovery: In case of failures, teams can quickly revert to a previous known good state by rolling back changes in the Git repository.</li> <li>Improved Collaboration: GitOps promotes collaboration among team members by leveraging familiar Git workflows and pull requests for code reviews and approvals.</li> </ul>"},{"location":"vi/devops/cicd/gitops-development/#implementing-gitops","title":"Implementing GitOps","text":"<ol> <li>Set Up a Git Repository: Create a Git repository to store your declarative configuration files for infrastructure and applications.</li> <li>Define Desired State: Write configuration files that define the desired state of your infrastructure and applications using tools like Kubernetes manifests, Helm charts, or Terraform scripts.</li> <li>Configure CI/CD Pipelines: Set up CI/CD pipelines to automatically apply changes from the Git repository to the target environment. Tools like Argo CD, Flux, or Jenkins can be used for this purpose.</li> <li>Monitor and Alert: Implement monitoring and alerting mechanisms to ensure the deployed state matches the desired state. Tools like Prometheus, Grafana, and Alertmanager can be used for observability.</li> </ol>"},{"location":"vi/devops/cicd/gitops-development/#my-simple-example","title":"My simple example","text":""},{"location":"vi/devops/cicd/gitops-development/#setup-git-repository","title":"Setup Git repository","text":"<p>I have a very simple website, it helps sending ebooks to eReaders (Kobo/Kindle) from PC or phones.</p> <p>The website: https://send.nghiendoc.com</p> <p></p> <p>You can find the source code of this website at: https://github.com/haoict/send2ereader</p>"},{"location":"vi/devops/cicd/gitops-development/#setup-ci","title":"Setup CI","text":"<p>First thing first, containerize your application, here's the Dockerfile https://github.com/haoict/send2ereader/blob/master/Dockerfile</p> <p>I use CircleCI to build docker image of the website whenever there's a push commit to the master branch. To setup CircleCI, there's a lot of tutorial on the internet. Here's my circleci's config: https://github.com/haoict/send2ereader/blob/master/.circleci/config.yml</p>"},{"location":"vi/devops/cicd/gitops-development/#setup-cd","title":"Setup CD","text":"<p>To deploy the application, I use Helm and Kubernetes, sorry but the helm chart repository is not open source, but here's how it looks like: </p> <p>My K8s cluster, (kind of, LOLOLOLOL): </p> <p>I use ArgoCD - a Kubernetes-native continuous deployment (CD) tool. Unlike external CD tools that only enable push-based deployments, Argo CD can pull updated code from Git repositories and deploy it directly to Kubernetes resources.</p>"},{"location":"vi/devops/cicd/gitops-development/#connecting-things-together","title":"Connecting things together","text":"<p>I want to add css to this website to make it look fancier. So I'm gonna make a new commit and push</p> <p>After pushed, CircleCI should build a new docker image when you push a new commit: </p> <p>Argo is the most important part of this GitOps development, after CircleCI finished building the app's docker image, I can get the image's tag and update it in the helm deployment.yaml</p> <p> </p> <p>After pushing the helm deployment.yaml update. Argo will automatically detect the change and deploy it</p> <p></p> <p>Now the website has a fresh look</p> <p></p>"},{"location":"vi/devops/cicd/gitops-development/#conclusion","title":"Conclusion","text":"<p>GitOps is a powerful approach to managing infrastructure and application deployments, offering numerous benefits in terms of consistency, reliability, and collaboration. By leveraging Git as the single source of truth and automating deployment processes, teams can achieve greater efficiency and agility in their operations. Implementing GitOps requires careful planning and adherence to best practices, but the rewards are well worth the effort.</p> <p>Embrace GitOps to streamline your development and operational workflows, and take your DevOps practices to the next level.</p>"},{"location":"vi/devops/docker/","title":"Devops","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"vi/devops/kubernetes/","title":"Devops","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"vi/devops/kubernetes/create-k0s-cluster/","title":"Install k0s cluster","text":"<p>K0s is a simple, standalone Kubernetes distribution focused on minimalism and flexibility. Provides essential Kubernetes components with a pluggable architecture. Suitable for development, testing, and production use cases.</p> <p>K0s is more general-purpose and flexible, while K3s is tailored for edge computing and IoT deployments. Your choice depends on your specific use case and resource requirements.</p> <pre><code>sudo su -\ncurl -sSLf https://get.k0s.sh | sudo sh\nsudo mkdir -p /etc/k0s\nsudo k0s config create | sudo tee /etc/k0s/k0s.yaml\nsudo nano /etc/k0s/k0s.yaml\n--&gt; Add externalAddress: https://docs.k0sproject.io/head/configuration/ (normally it should be the same with server's public IP)\nsudo k0s install controller -c /etc/k0s/k0s.yaml --enable-worker\nsudo k0s start\nsudo k0s status\n</code></pre>"},{"location":"vi/devops/kubernetes/create-k0s-cluster/#troubleshooting-if-errors","title":"Troubleshooting if errors","text":"<pre><code>sudo nano /etc/systemd/system/k0scontroller.service\nsudo systemctl daemon-reload\nsudo systemctl status k0scontroller.service\nsudo journalctl th\u00f4-u k0scontroller --follow\n</code></pre>"},{"location":"vi/devops/kubernetes/create-k0s-cluster/#access-cluster","title":"Access cluster","text":""},{"location":"vi/devops/kubernetes/create-k0s-cluster/#from-k0s-server","title":"from k0s server","text":"<pre><code>sudo k0s kubectl get nodes\n</code></pre>"},{"location":"vi/devops/kubernetes/create-k0s-cluster/#from-local-pc","title":"from local pc","text":"<pre><code># Get admin.conf from k0s server first\nmkdir -p ${HOME}/.k0s\nsudo cat /var/lib/k0s/pki/admin.conf\n\n\n# From your local PC\nnano ~/.k0s/kubeconfig\n--&gt; Paste the content of admin.conf\n\nexport KUBECONFIG=\"${HOME}/.k0s/kubeconfig\"\nkubectl get pods --all-namespaces\n</code></pre>"},{"location":"vi/devops/kubernetes/create-k0s-cluster/#uninstall","title":"Uninstall","text":"<pre><code>sudo k0s stop\nsudo k0s reset\n## Clean up\nsudo systemctl disable k0scontroller.service\nsudo rm /etc/systemd/system/k0scontroller.service\nsudo systemctl daemon-reload\n</code></pre>"},{"location":"vi/devops/kubernetes/create-k3s-cluster/","title":"Install k3s cluster","text":"<p>K3s is a ightweight Kubernetes distribution optimized for edge computing, IoT, and resource-constrained environments. Includes additional features like lightweight container runtime, built-in load balancer, and integrated storage solutions. Designed for devices with limited memory and CPU resources.</p> <p>K0s is more general-purpose and flexible, while K3s is tailored for edge computing and IoT deployments. Your choice depends on your specific use case and resource requirements.</p> <p>Docs:</p> <ul> <li>https://docs.k3s.io/quick-start</li> <li>https://0to1.nl/post/k3s-kubectl-permission/</li> </ul> <p>Quick way: <pre><code># install control-plane node (with disable traefik and custom token)\ncurl -sfL https://get.k3s.io | sh -s - --disable=traefik --kube-apiserver-arg service-node-port-range=30000-39999 --token 12345\n\n# install worker nodes (optional)\ncurl -sfL https://get.k3s.io | K3S_URL=https://192.168.195.151:6443 K3S_TOKEN=12345 sh -s -\n\n# optional: copy kubeconfig to user .kube\nsudo cp /etc/rancher/k3s/k3s.yaml ~/.kube/config &amp;&amp; chown $USER ~/.kube/config &amp;&amp; chmod 600 ~/.kube/config &amp;&amp; export KUBECONFIG=~/.kube/config\n## You probably want to store that export to your bashrc or bash_profile. After you changed this you can use kubectl in a new terminal.\n\n# optional: taint control-plane node\nkubectl taint node k3s-01 node-role.kubernetes.io/control-plane:NoSchedule\n</code></pre></p>"},{"location":"vi/devops/kubernetes/create-k3s-cluster/#delete-cluster","title":"Delete cluster","text":"<pre><code># Uninstalling Servers\n/usr/local/bin/k3s-uninstall.sh\n\n# Uninstalling Agents\n/usr/local/bin/k3s-agent-uninstall.sh\n</code></pre>"},{"location":"vi/devops/kubernetes/create-k8s-cluster/","title":"Install kubernetes official way","text":"<p>Docs:</p> <ul> <li>https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/</li> <li>https://www.webhi.com/how-to/setup-configure-kubernetes-on-ubuntu-debian-and-centos-rhel/</li> <li>https://serverfault.com/a/1118760</li> </ul>"},{"location":"vi/devops/kubernetes/create-k8s-cluster/#disable-swap","title":"Disable swap","text":"<p>Kubernetes performs best when swap is disabled. Disable it with the following commands:</p> <pre><code>sudo swapoff -a\nsudo sed -i '/ swap / s/^/#/' /etc/fstab\n</code></pre> <p>the swap patition will be unused, you may want to reclaim it and merge it to the root patition <pre><code># extend disk\nsudo cfdisk /dev/sda\n\n# check\nlsblk\nlsblk --fs\ndf -h\n\n# resize fs\nresize2fs /dev/sda1\n\n# check again\n</code></pre></p>"},{"location":"vi/devops/kubernetes/create-k8s-cluster/#install-containerd-by-docker-engine","title":"Install containerd (by docker engine)","text":"<pre><code># Set up Docker's apt repository. (https://docs.docker.com/engine/install/debian/)\n# Add Docker's official GPG key:\nsudo apt-get update\nsudo apt-get install ca-certificates curl\nsudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n\n# Add the repository to Apt sources:\necho \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian $(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\") stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\n\n# install containerd.io \nsudo apt-get install containerd.io\n\n# Create containerd configuration\nsudo mkdir -p /etc/containerd\nsudo containerd config default | sudo tee /etc/containerd/config.toml\nsudo nano /etc/containerd/config.toml # set SystemdCgroup = true\nsudo systemctl restart containerd\n</code></pre>"},{"location":"vi/devops/kubernetes/create-k8s-cluster/#install-kubernetes-components","title":"Install Kubernetes Components","text":"<pre><code>sudo apt-get update\nsudo apt-get install -y apt-transport-https ca-certificates curl gpg\ncurl -fsSL https://pkgs.k8s.io/core:/stable:/v1.29/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg\necho 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.29/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list # for other Kubernetes minor versions, you need to change the Kubernetes minor version in the URL to match your desired minor version\nsudo apt-get update\nsudo apt-get install -y kubelet kubeadm kubectl\nsudo apt-mark hold kubelet kubeadm kubectl\n\n# fix kubeadm init preflight issues\nsudo modprobe br_netfilter\ncat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-iptables  = 1\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.ipv4.ip_forward                 = 1\nEOF\nsudo sysctl --system\n\n# init cluster\nsudo kubeadm init --pod-network-cidr=10.244.0.0/16\n\n# post initialization\nmkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\n</code></pre>"},{"location":"vi/devops/kubernetes/create-k8s-cluster/#configure-pod-network","title":"Configure Pod Network","text":"<p>Select a Pod network add-on and install it. For instance, you can choose to install Calico: <pre><code>kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml\n</code></pre> or Flannel <pre><code>kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/v0.20.2/Documentation/kube-flannel.yml\n</code></pre></p>"},{"location":"vi/devops/kubernetes/create-k8s-cluster/#verify","title":"Verify","text":"<p>All should be running now: <pre><code>kubectl get pods --all-namespaces\n</code></pre></p>"},{"location":"vi/devops/kubernetes/create-k8s-cluster/#join-worker-nodes-if-there-are","title":"Join worker nodes (if there are)","text":"<p>After step \"fix kubeadm init preflight issues\", instead of running \"kubeadm init\", we run: (this command should be printed out after master node kubeadm init) <pre><code>kubeadm join 192.168.195.130:6443 --token $TOKEN --discovery-token-ca-cert-hash $HASH\n</code></pre></p>"},{"location":"vi/devops/kubernetes/create-k8s-cluster/#delete-cluster","title":"Delete cluster","text":"<pre><code>kubeadm reset\nsudo iptables -F &amp;&amp; sudo iptables -t nat -F &amp;&amp; sudo iptables -t mangle -F &amp;&amp; sudo iptables -X\n</code></pre>"},{"location":"vi/devops/kubernetes/create-kind-cluster/","title":"Install Kind","text":"<p>This page is a WIP, check back later for more contents</p> <p>There are quite a few ways to get Kubernetes up and running on your machine. On Rancher Desktop, you simply click a Kubernetes checkbox in the settings. With a WSL2 backend this is pretty good, except you need a special distro running just for Kubernetes. It's also not compatible with ARM. Without using Rancher Desktop, we'll be looking for a Linux solution, some come to mind, including:</p> <ul> <li>minikube</li> <li>microk8s (requires snap, which is a bit of a pain on WSL2)</li> <li>k3s (does some things on the OS level which are not ideal)</li> <li>k3d</li> <li>kind</li> </ul> <p>kind is my favourite because of how isolated it is inside docker, which makes it very easy to get going, and just as easy to remove. k3d is very similar, but not a certified distribution, so you'll probably have higher chance of success with kind.</p> <p>https://www.guide2wsl.com/kubernetes/ https://kind.sigs.k8s.io/docs/user/quick-start/</p> <pre><code>kind create cluster --config cluster.yaml\nkind delete cluster\n</code></pre> <pre><code>kind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nnodes:\n- role: control-plane\n  extraPortMappings:\n  - containerPort: 80\n    hostPort: 8080\n  - containerPort: 443\n    hostPort: 8443\n# - role: worker\n</code></pre>"},{"location":"vi/devops/terraform/","title":"Install Terraform","text":"<p>Docs:</p> <p>https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli</p>"},{"location":"vi/devops/terraform/#destroy-terraform","title":"Destroy Terraform","text":"<pre><code>terraform destroy\n\n# remove stuck resources\nNS=`kubectl get ns |grep Terminating | awk 'NR==1 {print $1}'` &amp;&amp; kubectl get namespace \"$NS\" -o json   | tr -d \"\\n\" | sed \"s/\\\"finalizers\\\": \\[[^]]\\+\\]/\\\"finalizers\\\": []/\"   | kubectl replace --raw /api/v1/namespaces/$NS/finalize -f -\n</code></pre> <p>This page is a WIP, check back later for more contents</p>"},{"location":"vi/misc/","title":"Misc","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"vi/operating-systems/","title":"Operating Systems","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"vi/operating-systems/linux/","title":"Operating Systems","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/","title":"Make your own Linux Distro From scratch","text":"<p>I'll call my distro name as: TiniLinux</p> <p>Welcome to TiniLinux, we will make a Linux Distro from scratch</p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/#theory","title":"Theory","text":"<p>To make a very tiny and simple Linux distro, we're going to need:</p> <ul> <li>Kernel</li> <li>User Space (in this case we use BusyBox)</li> <li>Bootloader (in this case we use Grub)</li> </ul> <pre><code>              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \n              \u2502     Power On       \u2502                     \n              \u2502                    \u2502                     \n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \n                        \u2502                                \n                        \u2502                                \n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \n              \u2502     BIOS/UEFI      \u2502                     \n              \u2502                    \u2502                     \n              \u2502       (POST)       \u2502                     \n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \n                        \u2502                                \n                        \u2502                                \n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \n              \u2502    Boot Device     \u2502                     \n              \u2502                    \u2502                     \n              \u2502  Hard Disk/CD/USB  \u2502                     \n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \n                        \u2502                                \n                        \u2502                                \n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \n              \u2502  Boot Loader(GRUB) \u2502                     \n              \u2502                    \u2502                     \n              \u2502  Load kernel and   \u2502                     \n              \u2502  initramfs to RAM  \u2502                     \n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \n                         \u2502                               \n                         \u2502                               \n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \n              \u2502       Kernel       \u2502                     \n              \u2502                    \u2502                     \n              \u2502 Execute /sbin/init \u2502                     \n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \n                         \u2502                               \n           (Live boot)   \u2502  (Boot from Hard disk)        \n           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \n           \u2502                            \u2502                \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \n\u2502   Init (initramfs) \u2502       \u2502  Init (initramfs)  \u2502      \n\u2502                    \u2502       \u2502  Mount Real rootfs \u2502      \n\u2502   Execute RunLevel \u2502       \u2502  from hard disk    \u2502      \n\u2502      programs      \u2502       \u2502  then switch_root  \u2502      \n\u2502                    \u2502       \u2502  exec /sbin/init   \u2502      \n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \n                                        \u2502                \n                                        \u2502                \n                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \n                             \u2502        Init        \u2502      \n                             \u2502                    \u2502      \n                             \u2502   Execute RunLevel \u2502      \n                             \u2502      programs      \u2502      \n                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \n                                        \u2502                \n                                        \u2502                \n                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \n                             \u2502  Systemd / OpenRC  \u2502      \n                             \u2502                    \u2502      \n                             \u2502   Execute System   \u2502      \n                             \u2502   Daemon programs  \u2502      \n                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \n\n(Drew with https://asciiflow.com/)\n</code></pre> <p>This applies to real world Linux distro as well (Debian, Ubuntu, Fedora,...)</p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/#steps","title":"Steps","text":"<p>This page is a WIP, check back later for more contents</p> <p>Here is a guide how to make a simple Linux Distro from scratch.</p> <ol> <li>Setup Environment </li> <li>Compile the kernel </li> <li>Compile Busybox </li> <li>Creating the initial ram filesystem (initramfs) </li> <li>Configuring the bootloader </li> <li>Package manager </li> <li>Docker </li> <li>Install to hard drive </li> <li>Appendix </li> </ol>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/#references","title":"References","text":"<ul> <li>https://www.youtube.com/watch?v=QlzoegSuIzg</li> <li>https://medium.com/@ThyCrow/compiling-the-linux-kernel-and-creating-a-bootable-iso-from-it-6afb8d23ba22</li> <li>https://medium.com/@GlobularOne/how-to-make-a-minimal-linux-distribution-from-source-code-5ff9b48dfc2</li> <li>https://gist.github.com/m13253/e4c3e3a56a23623d2e7e6796678b9e58</li> <li>https://kmahyyg.medium.com/tiny-image-dropbear-with-busybox-6f5b65a44dfb</li> <li>https://github.com/vmware/open-vm-tools/issues/696#issuecomment-1812710977 http://wiki.loverpi.com/faq:sbc:libre-aml-s805x-minimal-rootfs</li> <li>https://dariodip.medium.com/understanding-linux-containers-a-simple-recipe-7c24cc1137b4</li> </ul>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/1-setup-env/","title":"Setup Environment","text":""},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/1-setup-env/#1-setting-up-the-environment","title":"1. Setting up the environment:","text":"<p>Update the package list and install necessary tools:</p> <pre><code>sudo apt update\nsudo apt install build-essential git flex bison bc cpio libncurses5-dev libssl-dev libelf-dev\n\nexport WORKDIR=/home/${USER}/TiniLinux\n\nmkdir -p ${WORKDIR}/source                        # for linux kernel &amp; busybox source code\nmkdir -p ${WORKDIR}/build/amd64/initramfs         # for built kernel &amp; busybox\nmkdir -p ${WORKDIR}/build/amd64/uefi/boot/grub    # for making boot iso image\n</code></pre>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/2-kernel/","title":"Compile the kernel","text":""},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/2-kernel/#2-compile-the-kernel","title":"2. Compile the kernel:","text":"<p>Clone the Linux kernel source code:</p> <p><pre><code>cd ${WORKDIR}/source\n\ngit clone --depth=1 https://github.com/torvalds/linux.git\n\ncd linux\nmake defconfig\nmake menuconfig\n# Exit then save. The default config is good enough. (but nothing is stopping you from messing around it!)\n# NOTE: Fix Black Screen After Grub When Booting in UEFI\n# When booting in UEFI, after choosing your OS in grub, your screen might go blank and stay blank. This might indicate a problem in your kernel config\n# make menuconfig -&gt; press \"/\" button to search for config\n# Search for \"FB_EFI\" -&gt; Press \"1\" (the small number on the left of search result to quickly go to the config) -&gt; Press \"y\" -&gt; \"Esc Esc\" -&gt; \"1\" -&gt; \"y\"\n# Search for \"FRAMEBUFFER_CONSOLE\" -&gt; Press 1 -&gt; Press \"y\"\n\n# Some other recommended config to turn on:\n# IKCONFIG, IKCONFIG_PROC: read kernel .config through /proc/config.gz\n# EFIVAR_FS: mount EFI vars\n# OVERLAY_FS, BRIDGE, BRIDGE_NETFILTER, IP_NF_NAT, IP_NF_TARGET_MASQUERADE, VETH, IP_VS, NETFILTER_XT_MATCH_ADDRTYPE, NETFILTER_XT_MATCH_IPVS... (check more in docker section): to enable docker\n# HYPERV, HYPERV_KEYBOARD, HYPERV_NET, HYPERV_STORAGE, HYPERV_UTILS, (INPUT_MOUSEDEV, HID_HYPERV_MOUSE if enable GUI)\n# Save\n\n# to compile the kernel with all of your cores\nmake -j $(nproc)\n\ncp arch/x86/boot/bzImage ${WORKDIR}/build/amd64/uefi/boot/\n# cp arch/x86/boot/bzImage ${WORKDIR}/build/amd64/bios/boot/\n</code></pre> The compiled kernel image is copied to a directory named bootfiles.</p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/2-kernel/#kernel-modules","title":"Kernel modules","text":"<p>bzImage is the core of the kernel, which will be loaded to the memory from system boot to shutdown. Linux kernel support many features and drivers, you may not want to add them as built-in <code>[*]</code>, instead make them modules <code>[M]</code>, these can be loaded or unloaded after boot as hot plug when needed <pre><code># Copy compiled modules to a directory\nmake modules_install INSTALL_MOD_PATH=${WORKDIR}/build/amd64/kernel-modules/\n</code></pre></p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/3-busybox/","title":"Compile Busybox","text":""},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/3-busybox/#3-compile-busybox","title":"3. Compile Busybox:","text":"<p>BusyBox combines tiny versions of many common UNIX utilities into a single small executable.</p> <pre><code>cd ${WORKDIR}/source\n\ngit clone --depth=1 https://git.busybox.net/busybox\n\ncd busybox\nmake menuconfig\n# Now, enter the first sub-menu (Settings). Go down until you reach the section Build options. Select the Build static binary (no shared libs)\n# Optional: Go back to main menu. Scroll down until you find the Shells section. Two first options should be Choose which shell is aliased to 'sh' name and Choose which shell is aliased to 'bash' name. Choose each and tell BusyBox to alias sh to Ash and bash to Hush. You might also want to tweak some options but they are not required\n# Exit then save\nmake -j $(nproc)\nmake CONFIG_PREFIX=${WORKDIR}/build/amd64/initramfs install\n</code></pre> <p>The built Busybox binaries are installed into the <code>build/amd64/initramfs</code> directory. Now create a init script within initramfs to launch Busybox upon boot:</p> <pre><code>cd ${WORKDIR}/build/amd64/initramfs\n\ncat &lt;&lt;EOF &gt; init\n#!/bin/sh\n/bin/sh\nEOF\n\nchmod +x init\n</code></pre>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/3-busybox/#31-advance-advanced-init-and-login","title":"3.1. Advance (advanced init and login)","text":"<pre><code>cd ${WORKDIR}/build/amd64/initramfs\n\n# create some directories to give it a minimal Linux-like look\nmkdir -p {etc,dev,mnt,root,sys,proc,dev,run,tmp,var,home,etc/init.d}\n\n# /etc : We need to fill in a couple of files here\n\ncat &lt;&lt;EOF &gt; etc/inittab\n# https://github.com/brgl/busybox/blob/master/examples/inittab\n::sysinit:/etc/init.d/rcS\n\ntty1::respawn:/sbin/getty 0 tty1\ntty2::respawn:/sbin/getty 0 tty2\ntty3::respawn:/sbin/getty 0 tty3\ntty4::respawn:/sbin/getty 0 tty4\ntty5::respawn:/sbin/getty 0 tty5\ntty6::respawn:/sbin/getty 0 tty6\n\n# Enable these ttyS if you want to use serial (qemu -serial stdio)\n#ttyS0::respawn:/sbin/getty -L ttyS0 9600 vt100\n\n::restart:/sbin/init\n::ctrlaltdel:/sbin/reboot\n::shutdown:/bin/umount -a -r\n::shutdown:/sbin/swapoff -a\nEOF\n\n\ncat &lt;&lt;\\EOF &gt; etc/init.d/rcS\n#!/bin/sh\n\nmount -t sysfs    sysfs     -o nosuid,noexec,nodev    /sys\nmount -t proc     proc      -o nosuid,noexec,nodev    /proc\nmount -t devtmpfs devtmpfs  -o nosuid,mode=0755       /dev\nmount -t tmpfs    tmpfs     -o nosuid,nodev,mode=755  /run\nmkdir -p /dev/pts\nmount -t devpts   devpts    -o nosuid,gid=5,mode=620  /dev/pts\n\nmount -a\nmdev -s\n\nhostname tinilinux\nip link set lo up\necho 5 &gt; /proc/sys/kernel/printk\nsyslogd\n\ncat &lt;&lt;!\n\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\n\n  _____ _       _ _     _                  \n |_   _(_)_ __ (_) |   (_)_ __  _   ___  __\n   | | | | '_ \\| | |   | | '_ \\| | | \\ \\/ /\n   | | | | | | | | |___| | | | | |_| |&gt;  &lt; \n   |_| |_|_| |_|_|_____|_|_| |_|\\__,_/_/\\_\\\\\n\n\n\nWelcome to TiniLinux\n\n!\nEOF\n\n\nchmod +x etc/init.d/rcS\n\n\ncat &lt;&lt;EOF &gt; etc/hostname\ntinilinux\nEOF\n\n\ncat &lt;&lt;EOF &gt; etc/passwd\nroot::0:0:root:/root:/bin/bash\nEOF\n\n\ncat &lt;&lt;EOF &gt; etc/group\nroot:x:0:root\nEOF\n\n\ncat &lt;&lt;EOF &gt; etc/fstab\n# https://www.linuxfromscratch.org/lfs/view/10.0/chapter10/fstab.html\n# file system  mount-point  type     options                dump   fsck order\n\n# sysfs          /sys         sysfs    nosuid,noexec,nodev    0      0\n# proc           /proc        proc     nosuid,noexec,nodev    0      0\n# devtmpfs       /dev         devtmpfs nosuid,mode=0755       0      0\n# tmpfs          /run         tmpfs    nosuid,nodev,mode=755  0      0\n# devpts         /dev/pts     devpts   nosuid,gid=5,mode=620  0      0\n\n# /dev/sda2      /            ext4     defaults               0      1\n# /dev/sda1      /boot/efi    vfat     umask=0077             0      1\nEOF\n\n\ncat &lt;&lt;EOF &gt; init\n#!/bin/sh\nexec /linuxrc\nEOF\n\n\nchmod +x init\n</code></pre>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/3-busybox/#32-advance-network","title":"3.2. Advance (network)","text":"<pre><code>mkdir -p etc/network/if-up.d\nmkdir -p etc/network/if-pre-up.d\nmkdir -p etc/network/if-down.d\nmkdir -p etc/network/if-post-down.d\nmkdir -p var/run\nmkdir -p usr/share/udhcpc\n\n\ncat &lt;&lt;EOF &gt; etc/hosts\n127.0.0.1       localhost\n127.0.1.1       tinilinux\nEOF\n\n\ncat &lt;&lt;EOF &gt; etc/network/interfaces\n# enable dhcp for eth0 interface: https://wiki.alpinelinux.org/wiki/Udhcpc\nauto eth0\niface eth0 inet dhcp\n  hostname tinilinux\nEOF\n\n\ncat &lt;&lt;\\EOF &gt; usr/share/udhcpc/default.script\n#!/bin/ash\n\n# https://github.com/mschlenker/TinyCrossLinux/blob/master/patches/usr-share-udhcpc-default.script\n\nPATH=/bin:/sbin:/usr/bin:/usr/sbin\nexport PATH\n\n[ -z \"$1\" ] &amp;&amp; echo \"Error: should be called from udhcpc\" &amp;&amp; exit 1\n\nRESOLV_CONF=\"/etc/resolv.conf\"\n[ -n \"$broadcast\" ] &amp;&amp; BROADCAST=\"broadcast $broadcast\"\n[ -n \"$subnet\" ] &amp;&amp; NETMASK=\"netmask $subnet\"\n\ncase \"$1\" in\n  deconfig)\n    ifconfig $interface 0.0.0.0\n    ;;\n\n  renew|bound)\n    ifconfig $interface $ip $BROADCAST $NETMASK\n\n    if [ -n \"$router\" ] ; then\n      echo \"deleting routers\"\n      while route del default gw 0.0.0.0 dev $interface ; do\n        :\n      done\n\n      for i in $router ; do\n        route add default gw $i dev $interface\n      done\n    fi\n\n    echo -n &gt; $RESOLV_CONF\n    [ -n \"$domain\" ] &amp;&amp; echo search $domain &gt;&gt; $RESOLV_CONF\n    for i in $dns ; do\n      echo adding dns $i\n      echo nameserver $i &gt;&gt; $RESOLV_CONF\n    done\n    ;;\nesac\n\nexit 0\nEOF\n\n\nchmod +x usr/share/udhcpc/default.script\n\n# add line \"ifup eth0\" after \"ip link set lo up\":\nsed -i 's/ip link set lo up/ip link set lo up\\nifup eth0/g' etc/init.d/rcS\n</code></pre>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/3-busybox/#33-ssh-dropbear","title":"3.3. SSH (dropbear)","text":"<p>Build dropbear binary from source <pre><code>cd ${WORKDIR}/source\ngit clone --depth=1 https://github.com/mkj/dropbear.git\ncd dropbear\n./configure --enable-static\ncp src/default_options.h localoptions.h # update options if you want\nmake PROGRAMS=\"dropbear dbclient dropbearkey dropbearconvert scp\" MULTI=1 STATIC=1 strip\n</code></pre></p> <p>Copy dropbear binary to initramfs <pre><code>cp ${WORKDIR}/source/dropbear/dropbearmulti ${WORKDIR}/build/amd64/initramfs/usr/bin/\ncd ${WORKDIR}/build/amd64/initramfs/usr/bin/\nln -s dropbearmulti scp\nln -s dropbearmulti dropbearkey\nln -s dropbearmulti dropbearconvert\nln -s dropbearmulti dropbear\nln -s dropbearmulti ssh\nln -s dropbearmulti dbclien\n\ncd ${WORKDIR}/build/amd64/initramfs/\nmkdir -p {var/log,etc/default,etc/dropbear}\ntouch var/log/lastlog\n\ncat &lt;&lt;EOF &gt; etc/shells\n/bin/bash\n/bin/sh\nEOF\n</code></pre></p> <p>After boot, start dropbear with <pre><code>dropbear -EBR # log error on std error, allow blank password, create hostkey if required\n</code></pre></p> <p>or add to rcS <pre><code>sed -i 's/ifup eth0/ifup eth0 &amp;&amp; dropbear -RB/g' etc/init.d/rcS\n</code></pre></p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/3-busybox/#34-curl","title":"3.4. curl","text":"<p>I prefer curl over wget, so if you want to use curl <pre><code># check version and arch here: https://github.com/stunnel/static-curl/releases\ncurl -LO https://github.com/stunnel/static-curl/releases/download/8.6.0-1/curl-linux-x86_64-8.6.0.tar.xz\ntar -xvf curl-linux-x86_64-8.6.0.tar.xz\nrm curl-linux-x86_64-8.6.0.tar.xz\n\n# you may want to compress the binary: $ upx --brute curl\n\nmv curl usr/bin\n</code></pre></p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/4-initramfs/","title":"Creating the initial ram filesystem (initramfs)","text":""},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/4-initramfs/#4-creating-the-initial-ram-filesystem-initramfs","title":"4. Creating the initial ram filesystem (initramfs):","text":"<p>The find command is used to create a list of files within initramfs, and the cpio command archives them into a compressed image named initramfs.cpio.</p> <pre><code>cd ${WORKDIR}/build/amd64/initramfs/\nsudo chown -R root:root *\nfind . | cpio -o -H newc | gzip -9 &gt; ${WORKDIR}/build/amd64/uefi/boot/initramfs.cpio.gz\nsudo chown -R $USER:$(id -gn) *\n</code></pre> <p>Test the built kernel and initramfs <pre><code>sudo apt install qemu-system\n\nqemu-system-x86_64 -kernel bzImage -initrd initramfs.cpio.gz\nqemu-system-x86_64 -nographic -append console=ttyS0 -kernel bzImage -initrd initramfs.cpio.gz\n</code></pre></p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/5-bootloader/","title":"Configuring the bootloader","text":""},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/5-bootloader/#5-configuring-the-bootloader","title":"5. Configuring the bootloader:","text":""},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/5-bootloader/#51-use-grub-recommend","title":"5.1. Use grub (recommend)","text":"<p>We will use grub-mkrescue to create our bootable ISO. But before doing so, we have to know if our current host is booted with UEFI or BIOS. To do so, check if the folder /sys/firmware/efi exists on your system or not. If it does, your computer uses UEFI otherwise it\u2019s BIOS.</p> <p>So why knowing this is important? The grub-mkrescue uses the currently installed grub stuff to create the ISO image. This means that if your operating system is booted in BIOS, the chances are that the ISO created from grub-mkrescue does not support UEFI at all. In some cases, UEFI motherboards support booting BIOS images using CMS. But that\u2019s not always the case. If you want to make images for BIOS from UEFI host or vice versa, I suggest you to create a Debian virtual machine in VirtualBox. VirtualBox supports both BIOS and UEFI in it\u2019s motherboard settings. After choosing the appropriate one, install Debian (net install is sufficient) and move the folder which contains boot and grub folders to virtual machine</p> <p>If you use grub in wsl2: https://github.com/Microsoft/WSL/issues/807#issuecomment-356697269</p> <p>Create a folder somewhere with any name you want. I name it iso. Then create a folder called boot in it and inside boot create a folder called grub. Then copy bzImage and initramfs.cpio.gz into boot folder.</p> <pre><code>sudo apt install xorriso mtools\ncd ${WORKDIR}/build/amd64/\n</code></pre> <p>UEFI <pre><code>cat &lt;&lt;EOF &gt; uefi/boot/grub/grub.cfg\nset default=0\nset timeout=2\n# Load EFI video drivers. This device is EFI so keep the video mode while booting the linux kernel.\ninsmod efi_gop\ninsmod font\nif loadfont /boot/grub/fonts/unicode.pf2\nthen\n  insmod gfxterm\n  set gfxmode=auto\n  set gfxpayload=keep\n  terminal_output gfxterm\nfi\nmenuentry 'TiniLinux' --class os {\n  insmod gzio\n  insmod part_msdos\n  linux /boot/bzImage\n  initrd /boot/initramfs.cpio.gz\n}\nEOF\n\ngrub-mkrescue -o tinilinux-amd64-uefi.iso uefi\n</code></pre></p> <p>BIOS <pre><code>cat &lt;&lt;EOF &gt; bios/boot/grub/grub.cfg\nset default=0\nset timeout=2\nmenuentry 'TiniLinux' --class os {\n  insmod gzio\n  insmod part_msdos\n  linux /boot/bzImage\n  initrd /boot/initramfs.cpio.gz\n}\nEOF\n\ngrub-mkrescue -o tinilinux-bios-uefi.iso bios/\n</code></pre></p> <p>Note: uefi iso can boot with both uefi and bios</p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/5-bootloader/#52-use-syslinux","title":"5.2. Use syslinux","text":"<p>The syslinux package is installed to provide the bootloader. A blank disk image is created and formatted with a FAT filesystem. The kernel image and initramfs are copied to the disk image.</p> <pre><code># using syslinux\nsudo apt install syslinux dosfstools\ndd if=/dev/zero of=boot bs=1M count=50\nmkfs -t fat boot\nsyslinux boot\nmkdir m\nsudo mount boot m\ncp bzImage init.cpio m\numount m\n</code></pre> <p>Test: <pre><code>qemu-system-x86_64 boot\n</code></pre></p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/5-bootloader/#booting-the-distro","title":"Booting the distro:","text":"<p>The iso file now can be used with VirtualBox or VMWare or burn to USB/CD</p> <p>From here, the basic steps of making a Linux distro from scatch are complete</p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/6-package-manager/","title":"Install a package manager (apk)","text":""},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/6-package-manager/#install-a-package-manager-apk","title":"Install a package manager (apk)","text":"<p>We will use <code>apk</code> (Alpine package manager) from Alpine Linux because it's very lightweight and designed to run on RAM (as Alpine Linux)</p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/6-package-manager/#pre-install-in-the-iso-file","title":"Pre-install in the iso file","text":"<pre><code>cd ${WORKDIR}/build/amd64/initramfs\n\nwget https://gitlab.alpinelinux.org/api/v4/projects/5/packages/generic//v2.14.0/x86_64/apk.static\n\nsudo chroot .\n\ncp /bin/busybox /bin/busybox-bak # backup original busybox as apk add will replace it\ncat &lt;&lt;EOF &gt; /etc/resolv.conf\nnameserver 8.8.8.8\nEOF\nmv apk.static apk\nchmod +x apk\nmv apk /usr/bin/apk\nmkdir -p /lib/apk/db/\nmkdir -p /etc/apk/\ntouch /etc/apk/world\ncat &lt;&lt;EOF &gt; /etc/apk/repositories\nhttp://dl-cdn.alpinelinux.org/alpine/v3.19/main\nhttp://dl-cdn.alpinelinux.org/alpine/v3.19/community\nEOF\napk add --allow-untrusted --no-cache ca-certificates alpine-keys\ncat &lt;&lt;EOF &gt; /etc/apk/repositories\nhttps://dl-cdn.alpinelinux.org/alpine/v3.19/main\nhttps://dl-cdn.alpinelinux.org/alpine/v3.19/community\nEOF\nmv -f /bin/busybox-bak /bin/busybox\nrm -rf /lib/apk/exec\nrm -rf /lib/apk/db/lock\nrm -rf /var/cache/apk/*\n\nexit\n\nsudo rm -rf root/.bash_history\nsudo rm -rf root/.hush_history\n</code></pre>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/6-package-manager/#use-apk","title":"Use apk","text":"<p>After booted from the iso, we can use apk normally <pre><code>apk update\n\napk add bash wget coreutils\napk add python3\n</code></pre></p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/6-package-manager/#alpine-linux-utilities","title":"Alpine Linux utilities","text":"<p>Since we're using apk, it comes with a lot of useful utilities thanks to Alpine Linux <pre><code>apk add alpine-conf\n# https://wiki.alpinelinux.org/wiki/Alpine_setup_scripts\n\nsetup-sshd\nsetup-desktop\n</code></pre></p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/7-docker/","title":"Install docker","text":""},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/7-docker/#install-docker","title":"Install docker","text":""},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/7-docker/#check-kernel-config","title":"Check kernel config","text":"<p>In order to run docker, some kernel modules needs to be enabled. If you already enabled them, skip this part <pre><code># script to check kernel config for docker support (note: enable CONFIG_IKCONFIG + CONFIG_IKCONFIG_PROC from kernel make menuconfig first)\n# wget https://github.com/moby/moby/raw/master/contrib/check-config.sh\n# chmod +x check-config.sh\n# ./check-config.sh\n</code></pre></p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/7-docker/#install-by-package-manager-apk","title":"Install by package manager (apk)","text":"<pre><code>mkdir -p /lib/modules\n\napk add docker iptables-legacy\nrm /sbin/iptables\ncp /sbin/iptables-legacy /sbin/iptables\nrm /sbin/iptables-save\ncp /sbin/iptables-legacy-save /sbin/iptables-save\nrm /sbin/iptables-restore\ncp /sbin/iptables-legacy-restore /sbin/iptables-restore\n</code></pre>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/7-docker/#or-install-by-binary","title":"Or: Install by binary","text":"<p>TODO: add guide to install iptables  <pre><code>wget https://download.docker.com/linux/static/stable/x86_64/docker-26.0.0.tgz\ntar xzvf docker-26.0.0.tgz\ncp docker/* /usr/bin/\n</code></pre></p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/7-docker/#use-docker","title":"Use docker","text":"<p>Before running dockerd, cgroupfs needs to be mounted <pre><code># copy the cgroup2-mount.sh from hack/docker\nwget https://gist.githubusercontent.com/haoict/770e65bb718ddac6d10cbd7e0d39fcf7/raw/7d40ced18bb202cf82f25765547581224c5d609d/cgroup2-mount.sh\nchmod +x cgroup2-mount.sh\n./cgroup2-mount.sh\n</code></pre></p> <p>Start dockerd <pre><code>DOCKER_RAMDISK=true dockerd &amp; #(if run with live boot) OR\ndockerd &amp; #(if installed to hard disk)\n</code></pre></p> <p>Now you can use docker normally <pre><code>docker run -d --rm -p 8000:8000 haoict/hello-world\n</code></pre></p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/","title":"Install to hard drive","text":""},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/#install-to-hard-drive","title":"Install to hard drive","text":"<p>At this stage, everything is basically complete, you have a complete live boot ISO. You may want to install it to hard drive and use as or normal Operating System.</p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/#make-an-early-boot-initramfs","title":"Make an early boot initramfs","text":"<p>First, we have to have a new fresh early-boot initramfs. This early-boot initramfs is different from live boot initramfs as after installed to hard disk, when you boot, the bootloader will load the kernel and this early-boot initramfs, it will mount the hard drive (the main root filesystem) to /mnt/.root, switch_root to it, and then call /sbin/init again. After that the system will be init from root file system from the hard disk</p> <p>Boot Loader -&gt; Load Kernel + Load initramfs -&gt; switch_root to rootfs from hard disk</p> <pre><code>## Update initramfs for boot from hard drive, from your main PC:\n# if not yet have the initramfs-boot\n# cd ${WORKDIR}/source/busybox/\n# make CONFIG_PREFIX=${WORKDIR}/build/amd64/initramfs-boot install\ncd ${WORKDIR}/build/amd64/initramfs-boot\nmkdir dev proc sys run\n\ncat &lt;&lt;\\EOF &gt; init\n#!/bin/sh\n\nROOT=\"/mnt/.root\"\nROOT_DEV=\"/dev/sda2\"\n\necho \"init from initramfs\"\n\n# mount temporary filesystems\nmount -n -t devtmpfs devtmpfs /dev\nmount -n -t proc     proc     /proc\nmount -n -t sysfs    sysfs    /sys\nmount -n -t tmpfs    tmpfs    /run\n\n# mount new root\n[ -d ${ROOT} ] || mkdir -p ${ROOT}\nmount ${ROOT_DEV} ${ROOT}\n\n# switch to new rootfs and exec init\ncd ${ROOT}\nexec switch_root . \"/sbin/init\" \"$@\"\nEOF\n\nchmod +x init\n\n# rebuild initramfs\nmkdir ../initramfs/boot/\nsudo chown -R root:root * &amp;&amp; find . | cpio -o -H newc | gzip -9 &gt; ../initramfs/boot/initramfs.cpio.gz &amp;&amp; sudo chown -R $USER:$(id -gn) *\ncd ${WORKDIR}/build/amd64/initramfs\ncp ${WORKDIR}/source/linux/arch/x86/boot/bzImage ${WORKDIR}/build/amd64/initramfs/boot/\ncp -r ${WORKDIR}/build/amd64/kernel-modules/lib/modules ${WORKDIR}/build/amd64/initramfs/lib\n\n### Build the iso again and start booting from it, proceed to the next step\ncd ${WORKDIR}/build/amd64/initramfs\n\nsudo chown -R root:root * &amp;&amp; find . | cpio -o -H newc | gzip -9 &gt; ${WORKDIR}/build/amd64/uefi/boot/initramfs.cpio.gz &amp;&amp; sudo chown -R $USER:$(id -gn) *\ngrub-mkrescue -o ${WORKDIR}/build/amd64/tinilinux-amd64-uefi.iso ${WORKDIR}/build/amd64/uefi\n</code></pre>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/#start-installing-to-hard-drive","title":"Start installing to hard drive","text":"<p>Now boot using the iso, after booted from the iso: <pre><code>apk add --allow-untrusted --no-cache ca-certificates alpine-keys\napk add --no-cache bash wget lsblk cfdisk grub grub-bios grub-efi dosfstools e2fsprogs rsync efibootmgr\n\n\ncat &lt;&lt;EOF &gt; /etc/group\nroot:x:0:\ndaemon:x:1:\nbin:x:2:\nsys:x:3:\nadm:x:4:syslog\ntty:x:5:\ndisk:x:6:\nlp:x:7:\nmail:x:8:\nnews:x:9:\nuucp:x:10:\nman:x:12:\nproxy:x:13:\nkmem:x:15:\ndialout:x:20:\nfax:x:21:\nvoice:x:22:\ncdrom:x:24:\nfloppy:x:25:\ntape:x:26:\nsudo:x:27:\naudio:x:29:\ndip:x:30:\nwww-data:x:33:\nbackup:x:34:\noperator:x:37:\nlist:x:38:\nirc:x:39:\nsrc:x:40:\ngnats:x:41:\nshadow:x:42:\nutmp:x:43:\nvideo:x:44:\nsasl:x:45:\nplugdev:x:46:\nstaff:x:50:\ngames:x:60:\nusers:x:100:\nnogroup:x:65534:\nEOF\n\n\n# create partition\n# /dev/sda1: for boot   (must be vfat or fat32), 100MB is ok\n# /dev/sda2: for rootfs (can be ext4), the rest of disk storage\ncfdisk\n# choose GPT for UEFI or dos for BIOS boot\n# type can be default: Linux filesystem\n# remember to [Write] all /dev/sda* before [Quit]\n\nmdev -s\n\n# format partition with the correct type\nmkfs.fat -F32 /dev/sda1\nmkfs.ext4 /dev/sda2\n\n# mount disk and install grub\nmount /dev/sda2 /mnt\n\n## use rsync to copy the entire root filesystem to another location\nrsync -aAXv /* /mnt --exclude={/dev/*,/proc/*,/sys/*,/tmp/*,/run/*,/mnt/*,/media/*,/lost+found}\n\nmkdir -p /mnt/boot/efi\nmount /dev/sda1 /mnt/boot/efi\n\nmount --bind /dev/ /mnt/dev/\nmount --bind /proc/ /mnt/proc/\nmount --bind /sys/ /mnt/sys/\n\nchroot /mnt\n\nmount -t efivarfs efivarfs /sys/firmware/efi/efivars\n\ngrub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=TiniLinux-UEFI #--bootloader-id=GRUB --no-nvram --removable\n\n# then add this line to /etc/default/grub\ncat &lt;&lt;\\EOF &gt; /etc/default/grub\nGRUB_DISTRIBUTOR=\"TiniLinux\"\nGRUB_TIMEOUT=2\nGRUB_DISABLE_SUBMENU=y\nGRUB_DISABLE_RECOVERY=true\nGRUB_CMDLINE_LINUX_DEFAULT=\"quiet\"\nGRUB_CMDLINE_LINUX=\"\"\nEOF\n\n\n#check disk id: blkid\n#/dev/sda2: UUID=\"4c8d1658-283e-4a07-9ab6-7efd4623e094\" TYPE=\"ext4\"\n#/dev/sda1: UUID=\"8CE4-73DF\" TYPE=\"vfat\"\n\n# then add this line to /etc/grub.d/40_custom\ncat &lt;&lt;\\EOF &gt;&gt; /etc/grub.d/40_custom\nmenuentry \"TiniLinux\" {\n  set root=(hd0,gpt2)\n  echo \"Loading kernel...\"\n  linux /boot/bzImage root=/dev/sda2 ro quiet splash\n  echo \"Loading initramfs...\"\n  initrd /boot/initramfs.cpio.gz\n}\nEOF\n\n\nmv /etc/grub.d/30_uefi-firmware /etc/grub.d/50_uefi-firmware\n\n\nupdate-grub\n\n# check grub.cfg for the added menuentry\ncat /boot/grub/grub.cfg\n\nexit\numount /mnt/proc /mnt/sys/firmware/efi/efivars /mnt/sys /mnt/dev\nmkdir -p /mnt/dev/pts\numount /dev/sda1\numount /dev/sda2\nexit\n</code></pre></p> <p>Remove live boot CD or USB Now try boot from hard disk if it fail, from grub menu press e to edit the entry or press c to enter command line <pre><code>ls\nset root=(hd0,gpt2)\nlinux /boot/bzImage root=/dev/sda2\ninitrd /boot/initramfs.cpio.gz\nboot\n</code></pre> Now we can boot, after booted, run update-grub again Done</p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/#post-installation","title":"Post installation","text":"<p>After installation, you can do these steps to make your OS more Linux-like OS</p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/#rdd","title":"rdD","text":"<p>Contrary with rcS, this script will be excecuted when the system shutdown or restart <pre><code># add this line before any ::shutdown lines in /etc/inittab\n::shutdown:/etc/rcD\n\ncat &lt;&lt;\\EOF &gt;&gt; /etc/rcD\n#!/bin/sh\nifdown eth0\nEOF\nchmod +x /etc/rcD\n</code></pre></p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/#enable-syslogd","title":"Enable syslogd","text":"<pre><code># Add to /etc/init.d/rcS\nsyslogd\n\n# Now you can view system log\ncat /var/log/messages\n</code></pre>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/#users","title":"Users","text":"<p>Create normal users <pre><code>apk add shadow\ntouch /etc/shadow\nchmod 640 /etc/shadow\n\naddgroup haoict\nadduser haoict -G haoict\n\naddgroup -g 27 sudo\napk add sudo\nvi /etc/sudoers\n# uncomment %sudo   ALL=(ALL:ALL) ALL\naddgroup haoict sudo\n\nsudo chmod 666 /dev/urandom\nsudo chmod 666 /dev/null\nsudo chmod -R 777 /tmp\n</code></pre></p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/#disable-ipv6","title":"Disable ipv6","text":"<pre><code>echo 0 &gt; /proc/sys/net/ipv6/conf/all/autoconf\necho 0 &gt; /proc/sys/net/ipv6/conf/all/accept_ra\necho 1 &gt; /proc/sys/net/ipv6/conf/all/disable_ipv6\n</code></pre>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/8-install-to-hard-drive/#patch-the-kernel","title":"Patch the kernel","text":"<p>Sometimes you may want to add some features or driver modules, you can compile the kernel again and copy it to <code>/boot/</code> and <code>/lib/modules</code></p> <pre><code>cd ${WORKDIR}/source/linux\nmake menuconfig\nmake -j $(nproc)\nmake modules_install INSTALL_MOD_PATH=${WORKDIR}/build/amd64/kernel-modules/\n\nrsync -lr ${WORKDIR}/build/amd64/kernel-modules/lib/modules root@192.168.1.131:/lib/\nscp ${WORKDIR}/source/linux/arch/x86/boot/bzImage root@192.168.1.131:/boot/\n\n# to load kernel module\nmodprobe &lt;module_name&gt;\n\n# list loadable modules\nfind /lib/modules/$(uname -r) -type f -name '*.ko' \ncat /lib/modules/$(uname -r)/modules.alias #  (with alias)\n\n# list loaded modules\nlsmod\n</code></pre>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/99-appendix/","title":"Appendix","text":""},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/99-appendix/#cross-compilation-arm64","title":"Cross compilation (arm64)","text":"<pre><code>sudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu\n#make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig\nmake ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig\nmake ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j 8\nmake ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- CONFIG_PREFIX=${WORKDIR}/build/arm64/initramfs install\n\n# follow the same steps to create initramfs.cpio.gz\ncd ${WORKDIR}/build/arm64/initramfs\n\nsudo chown -R root:root * &amp;&amp; find . | cpio -o -H newc | gzip -9 &gt; ${WORKDIR}/build/arm64/uefi/boot/initramfs.cpio.gz &amp;&amp; sudo chown -R $USER:$(id -gn) * \n\n# test\n## ref: https://gist.github.com/billti/d904fd6124bf6f10ba2c1e3736f0f0f7\n## list cpu: qemu-system-aarch64 -M virt -cpu help\nqemu-system-aarch64 -m 2048 -cpu cortex-a72 -smp 4 -M virt -nographic -kernel Image -initrd initramfs.cpio.gz\n</code></pre> <p>Make the iso and boot?? TBD (I haven't figured out yet, beside a Raspberry Pi which is running well and I don't want to mess with it, I don't have any spare arm64 board)</p>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/99-appendix/#install-gui-x11","title":"Install GUI (X11)","text":"<pre><code>apk add alpine-conf\n# setup mdev: https://wiki.alpinelinux.org/wiki/Mdev\nsetup-devd udev # or apk add busybox-mdev-openrc\n\nsetup-desktop xfce\nrc-update del lightdm\nrc-status # check openrc\n\napk add xterm\napk add xf86-video-vmware xf86-video-fbdev xf86-video-vesa\n\n/sbin/openrc sysinit\n/sbin/openrc boot\n\nstartx # or startxfce4 or xinit xfce4-session\n# for gnome: xinit gnome-session\n# for mate: xinit mate-session\n# for plasma: xinit plasma_session\n\n# extra\napk add open-vm-tools xf86-input-vmmouse\n/etc/init.d/open-vm-tools start\nstartx\n</code></pre>"},{"location":"vi/operating-systems/linux/make-your-own-linux-distro-from-scratch/99-appendix/#all-in-one-command-for-built-test","title":"All in one command for built &amp; test","text":"<pre><code>cd ${WORKDIR}/build/amd64/initramfs\n\nsudo chown -R root:root * &amp;&amp; find . | cpio -o -H newc | gzip -9 &gt; ${WORKDIR}/build/amd64/uefi/boot/initramfs.cpio.gz &amp;&amp; sudo chown -R $USER:$(id -gn) *\ngrub-mkrescue -o ${WORKDIR}/build/amd64/tinilinux-amd64-uefi.iso ${WORKDIR}/build/amd64/uefi\n</code></pre>"},{"location":"vi/operating-systems/windows/","title":"Operating Systems","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"vi/operating-systems/windows/build-msdos-4.00-from-source/","title":"How to compile the MS-DOS from Microsoft open source","text":""},{"location":"vi/operating-systems/windows/build-msdos-4.00-from-source/#overview","title":"Overview","text":"<p>Recently Microsoft just opened source MS-DOS 4.0 under MIT license. Let's try to compile it.  </p> <p>MS-DOS github: https://github.com/microsoft/MS-DOS</p> <p>More info: https://cloudblogs.microsoft.com/opensource/2024/04/25/open-sourcing-ms-dos-4-0/</p>"},{"location":"vi/operating-systems/windows/build-msdos-4.00-from-source/#prepare","title":"Prepare","text":""},{"location":"vi/operating-systems/windows/build-msdos-4.00-from-source/#compiling-environment","title":"Compiling Environment","text":"<p>Since the toolchain shipped with the source code in the same repository are 16 bit binaries. We can't run it in modern Windows 10 or 11. We need to run it under a 16 bit Virtual machine or emulator. It can be FreeDOS (VM) or DOSBox (emulator). We'll use DOSBox because it's easy to setup and run directly in Windows 10/11.</p> <p>Download and setup DOSBox: https://www.dosbox.com/download.php?main=1</p> <p></p> <p>You can press Ctrl+F12 to increase CPU speed, around 18000-20000 cycles is a good number</p>"},{"location":"vi/operating-systems/windows/build-msdos-4.00-from-source/#obtain-the-source-code","title":"Obtain the source code","text":"<p>Download the source code from MS-DOS Github repo: https://github.com/microsoft/MS-DOS/archive/refs/heads/main.zip and then extract it</p> <p>or clone it with git clone command <pre><code>git clone --depth=1 https://github.com/microsoft/MS-DOS.git\n</code></pre></p> <p></p>"},{"location":"vi/operating-systems/windows/build-msdos-4.00-from-source/#mount-the-source-code-directory-to-dosbox","title":"Mount the source code directory to DOSBox","text":"<p>In order to use files from the host computer (Windows 10/11) in DOSBox, we have to mount it. In DOSBox Run this command: <pre><code># mount source code to driver D\nmount d c:\\Users\\Hao\\Download\\MS-DOS-main\\v4.0\n\n# go to the source code dir\nD:\ncd SRC\n\n# verify\nDIR\n</code></pre></p> <p>The command will mount the directory <code>C:\\Users\\Hao\\Download\\MS-DOS-main\\v4.0</code> (host computer) to driver <code>D:</code> of DOSBox. Remember to change <code>C:\\Users\\Hao\\Download\\MS-DOS-main\\v4.0</code> with your path in your computer</p> <p></p>"},{"location":"vi/operating-systems/windows/build-msdos-4.00-from-source/#compiling","title":"Compiling","text":""},{"location":"vi/operating-systems/windows/build-msdos-4.00-from-source/#first-try","title":"First try","text":"<p>From here, we can try to compile it. Run: <pre><code>RUNME.BAT\n</code></pre> it will print the guide how to build it. You can open <code>RUNME.BAT</code> from the host computer to see the whole file content</p> <p></p> <p>Basically there're 3 steps:</p> <ul> <li>Run <code>SETENV.BAT</code> to setup environment</li> <li>Run <code>NMAKE</code> command to start building</li> <li>Run <code>CPY outputDir</code> to copy the built files to the output folder</li> </ul> <p>Let's try it</p> <p><pre><code>SETENV.BAT\n\nNNAME\n</code></pre> </p> <p>There are errors due to file encoding (need to change to ASCII) and line ending differences between linux and DOS (need to change from LF to CRLF), we have to patch it. You can try to do it yourself or use my script to do it quickly.  </p>"},{"location":"vi/operating-systems/windows/build-msdos-4.00-from-source/#patch-the-source-code","title":"Patch the source code","text":"<p>Open PowerShell from host computer, <code>cd</code> to the <code>MS-DOS-main\\v4.0\\src</code> directory and run these commands one by one <pre><code>(Get-Content \"SETENV.BAT\") -replace \"tools\\\\lib\",\"tools\\bld\\lib\" | Set-Content -Path \"SETENV.BAT\" -Encoding ASCII\n(Get-Content \"SETENV.BAT\") -replace \"tools\\\\inc\",\"tools\\bld\\inc\" | Set-Content -Path \"SETENV.BAT\" -Encoding ASCII\n\n(Get-Content \"MAPPER/GETMSG.ASM\") -replace \"\\xEF\\xBF\\xBD|\\xC4\\xBF|\\xC4\\xB4\",\"#\" | Set-Content -Path \"MAPPER/GETMSG.ASM\" -Encoding ASCII\n(Get-Content \"SELECT/SELECT2.ASM\") -replace \"\\xEF\\xBF\\xBD|\\xC4\\xBF|\\xC4\\xB4\",\"#\" | Set-Content -Path \"SELECT/SELECT2.ASM\" -Encoding ASCII\n(Get-Content \"SELECT/USA.INF\") -replace \"\\xEF\\xBF\\xBD|\\xC4\\xBF|\\xC4\\xB4\",\"#\" | Set-Content -Path \"SELECT/USA.INF\" -Encoding ASCII\n\nGet-ChildItem -Path . -Filter *.BAT -Recurse -File | ForEach-Object {\n    echo $_.FullName\n    (Get-Content -raw $_.FullName) -replace \"(?&lt;!`r)`n\",\"`r`n\" | Set-Content -nonewline -Encoding ASCII $_.FullName\n}\nGet-ChildItem -Path . -Filter *.ASM -Recurse -File | ForEach-Object {\n    echo $_.FullName\n    (Get-Content -raw $_.FullName) -replace \"(?&lt;!`r)`n\",\"`r`n\" | Set-Content -nonewline -Encoding ASCII $_.FullName\n}\nGet-ChildItem -Path . -Filter *.SKL -Recurse -File | ForEach-Object {\n    echo $_.FullName\n    (Get-Content -raw $_.FullName) -replace \"(?&lt;!`r)`n\",\"`r`n\" | Set-Content -nonewline -Encoding ASCII $_.FullName\n}\nGet-ChildItem -Path . -Filter ZERO.DAT -Recurse -File | ForEach-Object {\n    echo $_.FullName\n    (Get-Content -raw $_.FullName) -replace \"(?&lt;!`r)`n\",\"`r`n\" | Set-Content -nonewline -Encoding ASCII $_.FullName\n}\nGet-ChildItem -Path . -Filter LOCSCR -Recurse -File | ForEach-Object {\n    echo $_.FullName\n    (Get-Content -raw $_.FullName) -replace \"(?&lt;!`r)`n\",\"`r`n\" | Set-Content -nonewline -Encoding ASCII $_.FullName\n}\n</code></pre></p> <p> </p> <p>Now let's build again <pre><code>cd D:\\SRC\nSETENV.BAT\nNMAKE\n</code></pre></p> <p>Tada!!! The build is successful. \ud83c\udf89\ud83c\udf89</p> <p></p>"},{"location":"vi/operating-systems/windows/build-msdos-4.00-from-source/#runing-the-compiled-ms-dos-40","title":"Runing the compiled MS-DOS 4.0","text":"<p>Now we can copy built files to the output directory. Run: <pre><code># make output dir\nmkdir D:\\BIN\n\nCPY D:\\BIN\n</code></pre></p> <p></p> <p>Now we're inside the built directory of the DOS 4.0, we can run the new built <code>COMMAND.COM</code> shell</p> <pre><code>cd D:\\BIN\n\n# set DOSBox version to 4\nver set 4\n\n# check version\nver\n# -&gt; you can see printed version is 4.00 from DOSBox\n# \"DOSBox version 0.74-3. Reported DOS version 4.00.\"\n\n# now call COMMAND.COM from D:\\BIN directory to swith shell\n\nCOMMAND.COM\n\n# check version, again\nver\n# -&gt;now  you can see printed version is 4.00 from the new shell\n# \"MS-DOS Version 4.00\"\n</code></pre> <p>That's it, now we're running MS-DOS 4.00 from the binaries we just built. Congratulations!!</p> <p></p>"},{"location":"vi/operating-systems/windows/build-msdos-4.00-from-source/#whats-next","title":"What's next?","text":"<p>From here, you can try to build a bootable image and boot it with Virtual Box or VMWare. Goodluck! </p>"},{"location":"vi/operating-systems/windows/wsl2-guide/","title":"WSL2 Guide","text":"<p>This page is a WIP, check back later for more contents</p>"},{"location":"vi/operating-systems/windows/wsl2-guide/#add-usb-drive-to-wsl","title":"Add USB Drive to WSL","text":"<p>Microsoft has a doccumentation of how to connect USB devices to WSL (https://learn.microsoft.com/en-us/windows/wsl/connect-usb), but it's essentially just passthrough usb bus, we can't mount the usb device yet because the WSL Linux kernel doesn't support USB mass storage. So we have to rebuild WSL Linux kernel, let's get started</p>"},{"location":"vi/operating-systems/windows/wsl2-guide/#rebuild-the-wsl-linux-kernel","title":"Rebuild the WSL Linux kernel","text":"<p>Go to WSL-Linux-Kernel github releases, download the latest source code (.tar.gz): https://github.com/microsoft/WSL2-Linux-Kernel/releases</p> <p>From inside a WSL instance, run: <pre><code># First, install build dependencies\nsudo apt install build-essential flex bison dwarves libssl-dev libelf-dev\n\n# Download source code\nwget https://github.com/microsoft/WSL2-Linux-Kernel/archive/refs/tags/linux-msft-wsl-5.15.153.1.tar.gz\ntar -zxvf linux-msft-wsl-5.15.153.1.tar.gz\ncd WSL2-Linux-Kernel-linux-msft-wsl-5.15.153.1\n\n# Get current kernel config\nsudo cp /proc/config.gz .\nsudo gunzip config.gz\nsudo mv config .config\n\n# update config to add USB Mass Storage support\nmake menuconfig\n# Go to Device Drivers -&gt; USB support -&gt; USB Mass Storage support. Press y to build as built-in [*]\nmake -j$(nproc)\n\n# Copy the built kernel image to Windows, change the path (/mnt/c/...) wherever you want\ncp arch/x86_64/boot/bzImage /mnt/c/Users/Hao/.\n</code></pre></p>"},{"location":"vi/operating-systems/windows/wsl2-guide/#update-wslconfig-to-use-our-kernel-image","title":"Update .wslconfig to use our kernel image","text":"<p>In Windows, go to your home folder (C:\\Users\\Hao), create a file named <code>.wslconfig</code> if not exist</p> <p>Edit the file, add these line <pre><code>[wsl2]\nkernel = C:\\\\Users\\\\Hao\\\\bzImage\n</code></pre></p> <p>Note: other <code>.wslconfig</code> settings can be found here: https://learn.microsoft.com/en-us/windows/wsl/wsl-config#global-configuration-options-with-wslconfig</p> <p>Now restart wsl, open powershell and run <pre><code>wsl --shutdown\nwsl\n</code></pre></p>"},{"location":"vi/operating-systems/windows/wsl2-guide/#attach-the-usb-drive-to-wsl","title":"Attach the USB drive to WSL","text":"<p>From here, you can follow the MS's documentation above (https://learn.microsoft.com/en-us/windows/wsl/connect-usb)</p> <p>Basically run: <pre><code># install usbipd\nwinget install --interactive --exact dorssel.usbipd-win\n\n# list usb\nusbipd list\n\n# You will see output like this, in this case, BUSID 2-3 is my connected usb\n#Connected:\n#BUSID  VID:PID    DEVICE                                                        STATE\n#1-1    05ac:8233  NCM Composite Device                                          Not shared\n#1-3    05ac:8262  USB Input Device                                              Not shared\n#2-3    14cd:1212  USB Mass Storage Device                                       Not shared\n\n# Bind the bus first\nusbipd bind --busid 2-3\n\n# Attach to WSL\nusbipd attach --wsl --busid 2-3\n</code></pre></p> <p>Now inside WSL instance, you can use it, some example commands <pre><code>lsusb\nlsblk\nmount -t ext4 /dev/sdb1 /mnt/usb\n</code></pre></p> <p>Once you are done using the device in WSL, you can detach it, run this command inside powershell <pre><code>usbipd detach --busid 2-3\n</code></pre></p>"},{"location":"vi/software-engineering/","title":"Software Engineering","text":"<p>This page is a WIP, check back later for more contents</p>"}]}